pragma solidity ^0.4.18;
// File: contracts/TulipsSaleInterface.sol

/** @title Crypto Tulips Initial Sale Interface
* @dev This interface sets the standard for initial sale
* contract. All future sale contracts should follow this.
*/
interface TulipsSaleInterface {
    function putOnInitialSale(uint256 tulipId) external;
    function createAuction(
        uint256 _tulipId,
        uint256 _startingPrice,
        uint256 _endingPrice,
        uint256 _duration,
        address _transferFrom
    )external;
}

// File: contracts/ERC721.sol

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="523637263712332a3b3d3f28373c7c313d">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function transfer(address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
}&#13;
&#13;
// File: contracts/ERC721MetaData.sol&#13;
&#13;
/// @title The external contract that is responsible for generatingmetadata for the tulips,&#13;
/// Taken from crypto kitties source. May change with our own implementation&#13;
contract ERC721Metadata {&#13;
    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.&#13;
    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {&#13;
        if (_tokenId == 1) {&#13;
            buffer[0] = "Hello World! :D";&#13;
            count = 15;&#13;
        } else if (_tokenId == 2) {&#13;
            buffer[0] = "I would definitely choose a medi";&#13;
            buffer[1] = "um length string.";&#13;
            count = 49;&#13;
        } else if (_tokenId == 3) {&#13;
            buffer[0] = "Lorem ipsum dolor sit amet, mi e";&#13;
            buffer[1] = "st accumsan dapibus augue lorem,";&#13;
            buffer[2] = " tristique vestibulum id, libero";&#13;
            buffer[3] = " suscipit varius sapien aliquam.";&#13;
            count = 128;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
// File: zeppelin-solidity/contracts/ownership/Ownable.sol&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
  address public owner;&#13;
&#13;
&#13;
  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);&#13;
&#13;
&#13;
  /**&#13;
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
   * account.&#13;
   */&#13;
  function Ownable() public {&#13;
    owner = msg.sender;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Throws if called by any account other than the owner.&#13;
   */&#13;
  modifier onlyOwner() {&#13;
    require(msg.sender == owner);&#13;
    _;&#13;
  }&#13;
&#13;
&#13;
  /**&#13;
   * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
   * @param newOwner The address to transfer ownership to.&#13;
   */&#13;
  function transferOwnership(address newOwner) public onlyOwner {&#13;
    require(newOwner != address(0));&#13;
    OwnershipTransferred(owner, newOwner);&#13;
    owner = newOwner;&#13;
  }&#13;
&#13;
}&#13;
&#13;
// File: zeppelin-solidity/contracts/lifecycle/Pausable.sol&#13;
&#13;
/**&#13;
 * @title Pausable&#13;
 * @dev Base contract which allows children to implement an emergency stop mechanism.&#13;
 */&#13;
contract Pausable is Ownable {&#13;
  event Pause();&#13;
  event Unpause();&#13;
&#13;
  bool public paused = false;&#13;
&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is not paused.&#13;
   */&#13;
  modifier whenNotPaused() {&#13;
    require(!paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev Modifier to make a function callable only when the contract is paused.&#13;
   */&#13;
  modifier whenPaused() {&#13;
    require(paused);&#13;
    _;&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to pause, triggers stopped state&#13;
   */&#13;
  function pause() onlyOwner whenNotPaused public {&#13;
    paused = true;&#13;
    Pause();&#13;
  }&#13;
&#13;
  /**&#13;
   * @dev called by the owner to unpause, returns to normal state&#13;
   */&#13;
  function unpause() onlyOwner whenPaused public {&#13;
    paused = false;&#13;
    Unpause();&#13;
  }&#13;
}&#13;
&#13;
// File: contracts/TulipsRoles.sol&#13;
&#13;
/*&#13;
* @title Crypto Tulips SaleAuction&#13;
* @dev .&#13;
*/&#13;
contract TulipsRoles is Pausable {&#13;
&#13;
    modifier onlyFinancial() {&#13;
        require(msg.sender == address(financialAccount));&#13;
        _;&#13;
    }&#13;
&#13;
    modifier onlyOperations() {&#13;
        require(msg.sender == address(operationsAccount));&#13;
        _;&#13;
    }&#13;
&#13;
    function TulipsRoles() Ownable() public {&#13;
        financialAccount = msg.sender;&#13;
        operationsAccount = msg.sender;&#13;
    }&#13;
&#13;
    address public financialAccount;&#13;
    address public operationsAccount;&#13;
&#13;
    function transferFinancial(address newFinancial) public onlyOwner {&#13;
        require(newFinancial != address(0));&#13;
        financialAccount = newFinancial;&#13;
    }&#13;
&#13;
    function transferOperations(address newOperations) public onlyOwner {&#13;
        require(newOperations != address(0));&#13;
        operationsAccount = newOperations;&#13;
    }&#13;
&#13;
}&#13;
&#13;
// File: contracts/TulipsStorage.sol&#13;
&#13;
contract TulipsStorage is TulipsRoles {&#13;
&#13;
    //// DATA&#13;
&#13;
    /*&#13;
    * Main tulip struct.&#13;
    * Visual Info is the dna used to create the tulip image&#13;
    * Visual Hash hash of the image file to confirm validity if needed.&#13;
    */&#13;
    struct Tulip {&#13;
        uint256 visualInfo;&#13;
        bytes32 visualHash;&#13;
    }&#13;
&#13;
    //// STORAGE&#13;
    /*&#13;
    * @dev Array of all tulips created indexed with tulipID.&#13;
    */&#13;
    Tulip[] public tulips;&#13;
&#13;
    /*&#13;
    * @dev Maps tulipId's to owner addreses&#13;
    */&#13;
    mapping (uint256 =&gt; address) public tulipIdToOwner;&#13;
&#13;
    /*&#13;
    * @dev Maps owner adress to number of tulips owned.&#13;
    * Bookkeeping for compliance with ERC20 and ERC721. Doesn't mean much in terms of&#13;
    * value of individual unfungable assets.&#13;
    */&#13;
    mapping (address =&gt; uint256) tulipOwnershipCount;&#13;
&#13;
    /// @dev Maps tulipId to approved reciever of a pending token transfer.&#13;
    mapping (uint256 =&gt; address) public tulipIdToApprovedTranserAddress;&#13;
}&#13;
&#13;
// File: contracts/TulipsTokenInterface.sol&#13;
&#13;
/*&#13;
* @title Crypto Tulips Token Interface&#13;
* @dev This contract provides interface to ERC721 support.&#13;
*/&#13;
contract TulipsTokenInterface is TulipsStorage, ERC721 {&#13;
&#13;
    //// TOKEN SPECS &amp; META DATA&#13;
&#13;
    /// @notice Name and symbol of the non fungible token, as defined in ERC721.&#13;
    string public constant name = "CryptoTulips";&#13;
    string public constant symbol = "CT";&#13;
&#13;
    /*&#13;
    * @dev This external contract will return Tulip metadata. We are making this changable in case&#13;
    * we need to update our current uri scheme later on.&#13;
    */&#13;
    ERC721Metadata public erc721Metadata;&#13;
&#13;
    /// @dev Set the address of the external contract that generates the metadata.&#13;
    function setMetadataAddress(address _contractAddress) public onlyOperations {&#13;
        erc721Metadata = ERC721Metadata(_contractAddress);&#13;
    }&#13;
&#13;
    //// EVENTS&#13;
&#13;
    /*&#13;
    * @dev Transfer event as defined in ERC721.&#13;
    */&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
&#13;
    /*&#13;
    * @dev Approval event as defined in ERC721.&#13;
    */&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
&#13;
    //// TRANSFER DATA&#13;
&#13;
    /*&#13;
    * @dev Maps tulipId to approved transfer address&#13;
    */&#13;
    mapping (uint256 =&gt; address) public tulipIdToApproved;&#13;
&#13;
&#13;
    //// PUBLIC FACING FUNCTIONS&#13;
    /*&#13;
    * @notice Returns total number of Tulips created so far.&#13;
    */&#13;
    function totalSupply() public view returns (uint) {&#13;
        return tulips.length - 1;&#13;
    }&#13;
&#13;
    /*&#13;
    * @notice Returns the number of Tulips owned by given address.&#13;
    * @param _owner The Tulip owner.&#13;
    */&#13;
    function balanceOf(address _owner) public view returns (uint256 count) {&#13;
        return tulipOwnershipCount[_owner];&#13;
    }&#13;
&#13;
    /*&#13;
    * @notice Returns the owner of the given Tulip&#13;
    */&#13;
    function ownerOf(uint256 _tulipId)&#13;
        external&#13;
        view&#13;
        returns (address owner)&#13;
    {&#13;
        owner = tulipIdToOwner[_tulipId];&#13;
&#13;
        // If owner adress is empty this is still a fresh Tulip waiting for its first owner.&#13;
        require(owner != address(0));&#13;
    }&#13;
&#13;
    /*&#13;
    * @notice Unlocks the tulip for transfer. The reciever can calltransferFrom() to&#13;
    * get ownership of the tulip. This is a safer method since you can revoke the transfer&#13;
    * if you mistakenly send it to an invalid address.&#13;
    * @param _to The reciever address. Set to address(0) to revoke the approval.&#13;
    * @param _tulipId The tulip to be transfered&#13;
    */&#13;
    function approve(&#13;
        address _to,&#13;
        uint256 _tulipId&#13;
    )&#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
        // Only an owner can grant transfer approval.&#13;
        require(tulipIdToOwner[_tulipId] == msg.sender);&#13;
&#13;
        // Register the approval&#13;
        _approve(_tulipId, _to);&#13;
&#13;
        // Emit approval event.&#13;
        Approval(msg.sender, _to, _tulipId);&#13;
    }&#13;
&#13;
    /*&#13;
    * @notice Transfers a tulip to another address without confirmation.&#13;
    * If the reciever's address is invalid tulip may be lost! Use approve() and transferFrom() instead.&#13;
    * @param _to The reciever address.&#13;
    * @param _tulipId The tulip to be transfered&#13;
    */&#13;
    function transfer(&#13;
        address _to,&#13;
        uint256 _tulipId&#13;
    )&#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
        // Safety checks for common mistakes.&#13;
        require(_to != address(0));&#13;
        require(_to != address(this));&#13;
&#13;
        // You can only send tulips you own.&#13;
        require(tulipIdToOwner[_tulipId] == msg.sender);&#13;
&#13;
        // Do the transfer&#13;
        _transfer(msg.sender, _to, _tulipId);&#13;
    }&#13;
&#13;
    /*&#13;
    * @notice This method allows the caller to recieve a tulip if the caller is the approved address&#13;
    * caller can also give another address to recieve the tulip.&#13;
    * @param _from Current owner of the tulip.&#13;
    * @param _to New owner of the tulip&#13;
    * @param _tulipId The tulip to be transfered&#13;
    */&#13;
    function transferFrom(&#13;
        address _from,&#13;
        address _to,&#13;
        uint256 _tulipId&#13;
    )&#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
        // Safety checks for common mistakes.&#13;
        require(_to != address(0));&#13;
        require(_to != address(this));&#13;
&#13;
        // Check for approval and valid ownership&#13;
        require(tulipIdToApproved[_tulipId] == msg.sender);&#13;
        require(tulipIdToOwner[_tulipId] == _from);&#13;
&#13;
        // Do the transfer&#13;
        _transfer(_from, _to, _tulipId);&#13;
    }&#13;
&#13;
    /// @notice Returns metadata for the tulip.&#13;
    /// @param _tulipId The tulip to recieve information on&#13;
    function tokenMetadata(uint256 _tulipId, string _preferredTransport) external view returns (string infoUrl) {&#13;
        // We will set the meta data scheme in an external contract&#13;
        require(erc721Metadata != address(0));&#13;
&#13;
        // Contracts cannot return string to each other so we do this&#13;
        bytes32[4] memory buffer;&#13;
        uint256 count;&#13;
        (buffer, count) = erc721Metadata.getMetadata(_tulipId, _preferredTransport);&#13;
&#13;
        return _toString(buffer, count);&#13;
    }&#13;
&#13;
    //// INTERNAL FUNCTIONS THAT ACTUALLY DO STUFF&#13;
    // These are called by public facing functions after sanity checks&#13;
&#13;
    function _transfer(address _from, address _to, uint256 _tulipId) internal {&#13;
        // Increase total Tulips owned by _to address&#13;
        tulipOwnershipCount[_to]++;&#13;
&#13;
        // Decrease total Tulips owned by _from address, if _from address is not empty&#13;
        if (_from != address(0)) {&#13;
            tulipOwnershipCount[_from]--;&#13;
        }&#13;
&#13;
        // Update mapping of tulipID -&gt; ownerAddress&#13;
        tulipIdToOwner[_tulipId] = _to;&#13;
&#13;
        // Emit the transfer event.&#13;
        Transfer(_from, _to, _tulipId);&#13;
    }&#13;
&#13;
    function _approve(uint256 _tulipId, address _approved) internal{&#13;
        tulipIdToApproved[_tulipId] = _approved;&#13;
        // Approve event is only sent on public facing function&#13;
    }&#13;
&#13;
    //// UTILITY FUNCTIONS&#13;
&#13;
    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="9dfceffcfef5f3f4f9ddf3f2e9f9f2e9b3f3f8e9">[email protected]</a>&gt;)&#13;
    ///  This method is licenced under the Apache License.&#13;
    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol&#13;
    function _toString(bytes32[4] _rawBytes, uint256 _stringLength)private view returns (string) {&#13;
        var outputString = new string(_stringLength);&#13;
        uint256 outputPtr;&#13;
        uint256 bytesPtr;&#13;
&#13;
        assembly {&#13;
            outputPtr := add(outputString, 32)&#13;
            bytesPtr := _rawBytes&#13;
        }&#13;
&#13;
        _memcpy(outputPtr, bytesPtr, _stringLength);&#13;
&#13;
        return outputString;&#13;
    }&#13;
&#13;
    function _memcpy(uint dest, uint src, uint len) private view {&#13;
        // Copy word-length chunks while possible&#13;
        for(; len &gt;= 32; len -= 32) {&#13;
            assembly {&#13;
                mstore(dest, mload(src))&#13;
            }&#13;
            dest += 32;&#13;
            src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint mask = 256 ** (32 - len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(src), not(mask))&#13;
            let destpart := and(mload(dest), mask)&#13;
            mstore(dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
}&#13;
&#13;
// File: contracts/TulipsCreation.sol&#13;
&#13;
/*&#13;
* @title Crypto Tulips Creation Mechanisms &amp; Core Contract&#13;
* @dev This contract provides methods in which we create new tulips.&#13;
*/&#13;
contract TulipsCreation is TulipsTokenInterface {&#13;
&#13;
    //// STATS &amp; LIMITS&#13;
    uint256 public constant TOTAL_TULIP_SUPPLY = 100000;&#13;
    uint256 public totalTulipCount;&#13;
&#13;
    //// Sale contract&#13;
    TulipsSaleInterface public initialSaleContract;&#13;
&#13;
    //// EVENTS&#13;
&#13;
    /*&#13;
    * @dev Announces creation of a new tulip.&#13;
    */&#13;
    event TulipCreation(uint256 tulipId, uint256 visualInfo);&#13;
&#13;
    /*&#13;
    * We have this in case we have to change the initial sale contract&#13;
    */&#13;
    function setSaleAuction(address _initialSaleContractAddress) external onlyOwner {&#13;
        initialSaleContract = TulipsSaleInterface(_initialSaleContractAddress);&#13;
    }&#13;
&#13;
    function getSaleAuctionAddress() external view returns(address){&#13;
        return address(initialSaleContract);&#13;
    }&#13;
&#13;
    //// CREATION INTERFACE&#13;
    /*&#13;
    * @dev This function mints a new Tulip .&#13;
    * @param _visualInfo Visual information used to generate tulip image.&#13;
    * @param _visualHash Keccak hash of generated image.&#13;
    */&#13;
    function createTulip( uint256 _visualInfo, bytes32 _visualHash )  external onlyOperations&#13;
        returns (uint)&#13;
    {&#13;
        require(totalTulipCount&lt;TOTAL_TULIP_SUPPLY);&#13;
&#13;
        Tulip memory tulip = Tulip({&#13;
            visualInfo: _visualInfo,&#13;
            visualHash: _visualHash&#13;
        });&#13;
&#13;
        uint256 tulipId = tulips.push(tulip) - 1;&#13;
&#13;
        // New created tulip is owned by initial sale auction at first&#13;
        tulipIdToOwner[tulipId] = address(initialSaleContract);&#13;
        initialSaleContract.putOnInitialSale(tulipId);&#13;
&#13;
        totalTulipCount++;&#13;
&#13;
        // Let the world know about this new tulip&#13;
        TulipCreation(&#13;
            tulipId, _visualInfo&#13;
        );&#13;
&#13;
        return tulipId;&#13;
    }&#13;
&#13;
    /*&#13;
    * @dev This method authorizes for transfer and puts tulip on auction on a single call.&#13;
    * This could be done in two seperate calls approve() and createAuction()&#13;
    * but this way we can offer a single operation version that canbe triggered from web ui.&#13;
    */&#13;
    function putOnAuction(&#13;
        uint256 _tulipId,&#13;
        uint256 _startingPrice,&#13;
        uint256 _endingPrice,&#13;
        uint256 _duration&#13;
    )&#13;
        external&#13;
        whenNotPaused&#13;
    {&#13;
&#13;
        require(tulipIdToOwner[_tulipId] == msg.sender);&#13;
&#13;
        tulipIdToApproved[_tulipId] = address(initialSaleContract);&#13;
&#13;
        initialSaleContract.createAuction(&#13;
            _tulipId,&#13;
            _startingPrice,&#13;
            _endingPrice,&#13;
            _duration,&#13;
            msg.sender&#13;
        );&#13;
    }&#13;
&#13;
&#13;
}