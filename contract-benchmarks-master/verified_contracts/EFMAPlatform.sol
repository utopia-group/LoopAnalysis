pragma solidity ^0.4.24;

// ////////////////////////////////////////////////////////////////////////////////////////////////////
//                     ___           ___           ___                    __      
//       ___          /  /\         /  /\         /  /\                  |  |\    
//      /__/\        /  /::\       /  /::\       /  /::|                 |  |:|   
//      \  \:\      /  /:/\:\     /  /:/\:\     /  /:|:|                 |  |:|   
//       \__\:\    /  /::\ \:\   /  /::\ \:\   /  /:/|:|__               |__|:|__ 
//       /  /::\  /__/:/\:\ \:\ /__/:/\:\_\:\ /__/:/_|::::\          ____/__/::::\
//      /  /:/\:\ \  \:\ \:\_\/ \__\/  \:\/:/ \__\/  /~~/:/          \__\::::/~~~~
//     /  /:/__\/  \  \:\ \:\        \__\::/        /  /:/              |~~|:|    
//    /__/:/        \  \:\_\/        /  /:/        /  /:/               |  |:|    
//    \__\/          \  \:\         /__/:/        /__/:/                |__|:|    
//                    \__\/         \__\/         \__\/                  \__\|    
//  ______   ______   ______   _____    _    _   ______  ______  _____ 
// | |  | \ | |  | \ / |  | \ | | \ \  | |  | | | |     | |     | | \ \ 
// | |__|_/ | |__| | | |  | | | |  | | | |  | | | |     | |---- | |  | |
// |_|      |_|  \_\ \_|__|_/ |_|_/_/  \_|__|_| |_|____ |_|____ |_|_/_/ 
// 
// TEAM X All Rights Received. http://teamx.club 
// This product is protected under license.  Any unauthorized copy, modification, or use without 
// express written consent from the creators is prohibited.
// v 0.1.3
// Any cooperation Please email: <a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="eb988e999d82888eab9f8e8a8693c588879e89">[email protected]</a>&#13;
// Follow these step to become a site owner:&#13;
// 1. fork git repository: https://github.com/teamx-club/escape-mmm&#13;
// 2. modify file: js/config.js&#13;
// 3. replace siteOwner with your address&#13;
// 4. search for how to use github pages and bind your domain, setup the forked repository&#13;
// 5. having fun, you will earn 5% every privode from your site page&#13;
// ////////////////////////////////////////////////////////////////////////////////////////////////////&#13;
&#13;
//=========================================================...&#13;
// (~   _  _ _|_ _  .&#13;
// (_\/(/_| | | _\  . Events&#13;
//=========================================================                   &#13;
contract EscapeMmmEvents {&#13;
    event onOffered (&#13;
        address indexed playerAddress,&#13;
        uint256 offerAmount,&#13;
        address affiliateAddress,&#13;
        address siteOwner,&#13;
        uint256 timestamp&#13;
    );&#13;
    event onAccepted (&#13;
        address indexed playerAddress,&#13;
        uint256 acceptAmount&#13;
    );&#13;
    event onWithdraw (&#13;
        address indexed playerAddress,&#13;
        uint256 withdrawAmount&#13;
    );&#13;
    event onAirDrop (&#13;
        address indexed playerAddress,&#13;
        uint256 airdropAmount,&#13;
        uint256 offerAmount&#13;
    );&#13;
}&#13;
&#13;
/**&#13;
 * @title Ownable&#13;
 * @dev The Ownable contract has an owner address, and provides basic authorization control&#13;
 * functions, this simplifies the implementation of "user permissions".&#13;
 */&#13;
contract Ownable {&#13;
    address public owner;&#13;
&#13;
&#13;
    event OwnershipRenounced(address indexed previousOwner);&#13;
    event OwnershipTransferred(&#13;
        address indexed previousOwner,&#13;
        address indexed newOwner&#13;
    );&#13;
&#13;
&#13;
    /**&#13;
    * @dev The Ownable constructor sets the original `owner` of the contract to the sender&#13;
    * account.&#13;
    */&#13;
    constructor() public {&#13;
        owner = msg.sender;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Throws if called by any account other than the owner.&#13;
    */&#13;
    modifier onlyOwner() {&#13;
        require(msg.sender == owner);&#13;
        _;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Allows the current owner to relinquish control of the contract.&#13;
    * @notice Renouncing to ownership will leave the contract without an owner.&#13;
    * It will not be possible to call the functions with the `onlyOwner`&#13;
    * modifier anymore.&#13;
    */&#13;
    function renounceOwnership() public onlyOwner {&#13;
        emit OwnershipRenounced(owner);&#13;
        owner = address(0);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Allows the current owner to transfer control of the contract to a newOwner.&#13;
    * @param _newOwner The address to transfer ownership to.&#13;
    */&#13;
    function transferOwnership(address _newOwner) public onlyOwner {&#13;
        _transferOwnership(_newOwner);&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Transfers control of the contract to a newOwner.&#13;
    * @param _newOwner The address to transfer ownership to.&#13;
    */&#13;
    function _transferOwnership(address _newOwner) internal {&#13;
        require(_newOwner != address(0));&#13;
        emit OwnershipTransferred(owner, _newOwner);&#13;
        owner = _newOwner;&#13;
    }&#13;
}&#13;
&#13;
//=========================================================...&#13;
// |\/| _ . _   /~` _  _ _|_ _ _  __|_  .&#13;
// |  |(_||| |  \_,(_)| | | | (_|(_ |   . Main Contract&#13;
//=========================================================                   &#13;
contract EFMAPlatform is EscapeMmmEvents, Ownable {&#13;
    using SafeMath for *;&#13;
&#13;
    //=========================================================...&#13;
    //  _ _  _  |`. _     _ _  .&#13;
    // (_(_)| |~|~|(_||_|| (/_ .  system settings&#13;
    //==============_|=========================================        &#13;
    string constant public name = "Escape Financial Mutual Aid Platform";&#13;
    string constant public symbol = "EFMAP";&#13;
&#13;
    address private xTokenAddress = 0xfe8b40a35ff222c8475385f74e77d33954531b41;&#13;
&#13;
    uint8 public feePercent_ = 1; // 1% for fee&#13;
    uint8 public affPercent_ = 5; // 5% for affiliate&#13;
    uint8 public sitePercent_ = 5; // 5% for site owner&#13;
    uint8 public airDropPercent_ = 10; // 10% for air drop&#13;
    uint8 public xTokenPercent_ = 3; // 3% for x token&#13;
&#13;
    uint256 constant public interestPeriod_ = 1 hours;&#13;
    uint256 constant public maxInterestTime_ = 7 days;&#13;
    //=========================================================...&#13;
    //  _| _ _|_ _    _ _ _|_   _  .&#13;
    // (_|(_| | (_|  _\(/_ ||_||_) . data setup&#13;
    //=========================|===============================  &#13;
    uint256 public airDropPool_;&#13;
    uint256 public airDropTracker_ = 0; // +1 every (0.001 ether) time triggered; if 0.002 eth, trigger twice&#13;
&#13;
    //=========================================================...&#13;
    //  _ | _ _|_|` _  _ _ _    _| _ _|_ _  .&#13;
    // |_)|(_| |~|~(_)| | | |  (_|(_| | (_| . platform data&#13;
    //=|=======================================================&#13;
    mapping (address =&gt; FMAPDatasets.Player) public players_;&#13;
    mapping (address =&gt; mapping (uint256 =&gt; FMAPDatasets.OfferInfo)) public playerOfferOrders_; // player =&gt; player offer count =&gt; offerInfo.&#13;
    mapping (address =&gt; mapping (uint256 =&gt; uint256)) public playerAcceptOrders_; // player =&gt; count =&gt; orderId. player orders to accept;&#13;
    uint256 private restOfferAmount_ = 0; // offered amount that not been accepted;&#13;
    FMAPDatasets.AcceptOrder private currentOrder_; // unmatched current order;&#13;
    mapping (uint256 =&gt; FMAPDatasets.AcceptOrder) public acceptOrders_; // accept orders;&#13;
&#13;
    address private teamXWallet;&#13;
    uint256 public _totalFee;&#13;
    uint256 public _totalXT;&#13;
&#13;
    //=========================================================...&#13;
    //  _ _  _  __|_ _   __|_ _  _&#13;
    // (_(_)| |_\ | ||_|(_ | (_)| &#13;
    //=========================================================&#13;
    constructor() public {&#13;
        teamXWallet = msg.sender;&#13;
        // setting something ?&#13;
        FMAPDatasets.AcceptOrder memory ao;&#13;
        ao.nextOrder = 1;&#13;
        ao.playerAddress = msg.sender;&#13;
        ao.acceptAmount = 1 finney;&#13;
        acceptOrders_[0] = ao;&#13;
        currentOrder_ = ao;&#13;
    }&#13;
&#13;
    function transFee() public onlyOwner {&#13;
        teamXWallet.transfer(_totalFee);&#13;
    }&#13;
    function setTeamWallet(address wallet) public onlyOwner {&#13;
        teamXWallet = wallet;&#13;
    }&#13;
    function setXToken(address xToken) public onlyOwner {&#13;
        xTokenAddress = xToken;&#13;
    }&#13;
&#13;
    //=========================================================...&#13;
    //  _ _  _  _|. |`. _  _ _ .&#13;
    // | | |(_)(_||~|~|(/_| _\ . modifiers&#13;
    //=========================================================&#13;
    modifier isHuman() {&#13;
        require(AddressUtils.isContract(msg.sender) == false, "sorry, only human allowed");&#13;
        _;&#13;
    }&#13;
&#13;
    //=========================================================...&#13;
    //  _    |_ |. _   |`    _  __|_. _  _  _  .&#13;
    // |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\  . public functions&#13;
    //=|=======================================================&#13;
    /**&#13;
     * offer help directly&#13;
     */&#13;
    function() isHuman() public payable {&#13;
        FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(address(0), msg.value);&#13;
        offerCore(offerInfo, false);&#13;
    }&#13;
&#13;
    function offerHelp(address siteOwner, address affiliate) isHuman() public payable {&#13;
        FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(siteOwner, msg.value);&#13;
        bool updateAff = false;&#13;
        if(affiliate != address(0) &amp;&amp; affiliate != offerInfo.affiliateAddress) {&#13;
            offerInfo.affiliateAddress = affiliate;&#13;
            updateAff = true;&#13;
        }&#13;
        offerCore(offerInfo, updateAff);&#13;
&#13;
        emit onOffered(offerInfo.playerAddress, offerInfo.offerAmount, offerInfo.affiliateAddress, offerInfo.siteOwner, offerInfo.timestamp);&#13;
    }&#13;
&#13;
    function offerHelpUsingBalance(address siteOwner, address affiliate, uint256 ethAmount) isHuman() public {&#13;
        require(ethAmount &lt;= players_[msg.sender].balance, "sorry, you don't have enough balance");&#13;
        FMAPDatasets.OfferInfo memory offerInfo = packageOfferInfo(siteOwner, ethAmount);&#13;
        bool updateAff = false;&#13;
        if(affiliate != address(0) &amp;&amp; affiliate != offerInfo.affiliateAddress) {&#13;
            offerInfo.affiliateAddress = affiliate;&#13;
            updateAff = true;&#13;
        }&#13;
        players_[msg.sender].balance = players_[msg.sender].balance.sub(ethAmount);&#13;
        offerCore(offerInfo, updateAff);&#13;
&#13;
        emit onOffered(offerInfo.playerAddress, offerInfo.offerAmount, offerInfo.affiliateAddress, offerInfo.siteOwner, offerInfo.timestamp);&#13;
    }&#13;
&#13;
    function acceptHelp(uint256 amount) isHuman() public returns (uint256 canAcceptLeft) {&#13;
        (canAcceptLeft, ) = calcCanAcceptAmount(msg.sender, true, 0);&#13;
        require(amount &lt;= canAcceptLeft, "sorry, you don't have enough acceptable amount");&#13;
&#13;
        uint256 _nextOrderId = currentOrder_.nextOrder;&#13;
        FMAPDatasets.AcceptOrder memory acceptOrder;&#13;
        acceptOrder.playerAddress = msg.sender;&#13;
        acceptOrder.acceptAmount = amount;&#13;
        acceptOrder.acceptedAmount = 0;&#13;
        acceptOrder.nextOrder = _nextOrderId + 1;&#13;
        acceptOrders_[_nextOrderId] = acceptOrder;&#13;
&#13;
        // see if currentOrder_ is finished&#13;
        if (currentOrder_.orderId == _nextOrderId || currentOrder_.acceptAmount == currentOrder_.acceptedAmount) {&#13;
            currentOrder_ = acceptOrder;&#13;
        }&#13;
&#13;
        players_[acceptOrder.playerAddress].totalAccepted = amount.add(players_[acceptOrder.playerAddress].totalAccepted);&#13;
        players_[acceptOrder.playerAddress].acceptOrderCount++;&#13;
&#13;
        if (restOfferAmount_ &gt; 0) {&#13;
            matching();&#13;
        }&#13;
        calcAndSetPlayerTotalCanAccept(acceptOrder.playerAddress, amount);&#13;
&#13;
        emit onAccepted(acceptOrder.playerAddress, acceptOrder.acceptAmount);&#13;
&#13;
        return (canAcceptLeft);&#13;
    }&#13;
&#13;
    function withdraw() isHuman() public {&#13;
        require(players_[msg.sender].balance &gt;= 1 finney, "sorry, withdraw at least 1 finney");&#13;
&#13;
        uint256 _balance = players_[msg.sender].balance;&#13;
        players_[msg.sender].balance = 0;&#13;
        msg.sender.transfer(_balance);&#13;
&#13;
        emit onWithdraw(msg.sender, _balance);&#13;
    }&#13;
&#13;
    //=========================================================...&#13;
    //   . _      |`    _  __|_. _  _  _  .&#13;
    // \/|(/_VV  ~|~|_|| |(_ | |(_)| |_\  . view functions&#13;
    //=========================================================&#13;
    function getCanAcceptAmount(address playerAddr) public view returns (uint256 canAccept, uint256 earliest) {&#13;
        (canAccept, earliest) = calcCanAcceptAmount(playerAddr, true, 0);&#13;
        return (canAccept, earliest);&#13;
    }&#13;
&#13;
    function getBalance(address playerAddr) public view returns (uint256) {&#13;
        uint256 balance = players_[playerAddr].balance;&#13;
        return (balance);&#13;
    }&#13;
&#13;
    function getPlayerInfo(address playerAddr) public view&#13;
        returns (uint256 totalAssets, uint256 nextPeriodAssets, uint256 balance, uint256 canAccept, uint256 airdrop, uint256 offered, uint256 accepted, uint256 affiliateEarned, uint256 siteEarned, uint256 nextUpdateTime) {&#13;
        FMAPDatasets.Player memory _player = players_[playerAddr];&#13;
        uint256 _calculatedCanAccept;&#13;
        (_calculatedCanAccept, ) = calcCanAcceptAmount(playerAddr, false, 0);&#13;
        totalAssets = _player.balance.add(_calculatedCanAccept);&#13;
        (_calculatedCanAccept, ) = calcCanAcceptAmount(playerAddr, false, interestPeriod_);&#13;
        nextPeriodAssets = _player.balance.add(_calculatedCanAccept);&#13;
        (canAccept, nextUpdateTime) = calcCanAcceptAmount(playerAddr, true, 0);&#13;
&#13;
        return (totalAssets, nextPeriodAssets, _player.balance, canAccept, _player.airDroped, _player.totalOffered, _player.totalAccepted, _player.affiliateEarned, _player.siteEarned, nextUpdateTime);&#13;
    }&#13;
&#13;
    //=========================================================...&#13;
    //  _  _.   _ _|_ _    |`    _  __|_. _  _  _  .&#13;
    // |_)| |\/(_| | (/_  ~|~|_|| |(_ | |(_)| |_\  . private functions&#13;
    //=|=======================================================&#13;
    function packageOfferInfo(address siteOwner, uint256 amount) private view returns (FMAPDatasets.OfferInfo) {&#13;
        FMAPDatasets.OfferInfo memory offerInfo;&#13;
        offerInfo.playerAddress = msg.sender;&#13;
        offerInfo.offerAmount = amount;&#13;
        offerInfo.affiliateAddress = players_[msg.sender].lastAffiliate;&#13;
        offerInfo.siteOwner = siteOwner;&#13;
        offerInfo.timestamp = block.timestamp;&#13;
        offerInfo.interesting = true;&#13;
        return (offerInfo);&#13;
    }&#13;
&#13;
    //=========================================================...&#13;
    //  _ _  _ _    |`    _  __|_. _  _  _  .&#13;
    // (_(_)| (/_  ~|~|_|| |(_ | |(_)| |_\  .  core functions&#13;
    //=========================================================&#13;
    function offerCore(FMAPDatasets.OfferInfo memory offerInfo, bool updateAff) private {&#13;
        uint256 _fee = (offerInfo.offerAmount).mul(feePercent_).div(100); // 1% for fee&#13;
        uint256 _aff = (offerInfo.offerAmount).mul(affPercent_).div(100); // 5% for affiliate&#13;
        uint256 _sit = (offerInfo.offerAmount).mul(sitePercent_).div(100); // 5% for site owner&#13;
        uint256 _air = (offerInfo.offerAmount).mul(airDropPercent_).div(100); // 10% for air drop&#13;
        uint256 _xt = (offerInfo.offerAmount).mul(xTokenPercent_).div(100); // 3% for x token&#13;
&#13;
        uint256 _leftAmount = offerInfo.offerAmount;&#13;
&#13;
        if (offerInfo.affiliateAddress == offerInfo.siteOwner) { // site owner is forbid to be affiliater&#13;
            offerInfo.affiliateAddress = address(0);&#13;
        }&#13;
        // fee&#13;
        players_[offerInfo.playerAddress].totalOffered = (offerInfo.offerAmount).add(players_[offerInfo.playerAddress].totalOffered);&#13;
        if (offerInfo.affiliateAddress == address(0) || offerInfo.affiliateAddress == offerInfo.playerAddress) {&#13;
            _fee = _fee.add(_aff);&#13;
            _aff = 0;&#13;
        }&#13;
        if (offerInfo.siteOwner == address(0) || offerInfo.siteOwner == offerInfo.playerAddress) {&#13;
            _fee = _fee.add(_sit);&#13;
            _sit = 0;&#13;
        }&#13;
&#13;
        _totalFee = _totalFee.add(_fee);&#13;
        _totalXT = _totalXT.add(_xt);&#13;
        if (_totalXT &gt; 1 finney) {&#13;
            xTokenAddress.transfer(_totalXT);&#13;
        }&#13;
&#13;
        _leftAmount = _leftAmount.sub(_fee);&#13;
&#13;
        // affiliate&#13;
        if (_aff &gt; 0) {&#13;
            players_[offerInfo.affiliateAddress].balance = _aff.add(players_[offerInfo.affiliateAddress].balance);&#13;
            players_[offerInfo.affiliateAddress].affiliateEarned = _aff.add(players_[offerInfo.affiliateAddress].affiliateEarned);&#13;
            _leftAmount = _leftAmount.sub(_aff);&#13;
        }&#13;
        // site&#13;
        if (_sit &gt; 0) {&#13;
            players_[offerInfo.siteOwner].balance = _sit.add(players_[offerInfo.siteOwner].balance);&#13;
            players_[offerInfo.siteOwner].siteEarned = _sit.add(players_[offerInfo.siteOwner].siteEarned);&#13;
            _leftAmount = _leftAmount.sub(_sit);&#13;
        }&#13;
&#13;
        // air drop&#13;
        if (offerInfo.offerAmount &gt;= 1 finney) {&#13;
            airDropTracker_ = airDropTracker_ + FMAPMath.calcTrackerCount(offerInfo.offerAmount);&#13;
            if (airdrop() == true) {&#13;
                uint256 _airdrop = FMAPMath.calcAirDropAmount(offerInfo.offerAmount);&#13;
                players_[offerInfo.playerAddress].balance = _airdrop.add(players_[offerInfo.playerAddress].balance);&#13;
                players_[offerInfo.playerAddress].airDroped = _airdrop.add(players_[offerInfo.playerAddress].airDroped);&#13;
                emit onAirDrop(offerInfo.playerAddress, _airdrop, offerInfo.offerAmount);&#13;
            }&#13;
        }&#13;
        airDropPool_ = airDropPool_.add(_air);&#13;
        _leftAmount = _leftAmount.sub(_air);&#13;
&#13;
        if (updateAff) {&#13;
            players_[offerInfo.playerAddress].lastAffiliate = offerInfo.affiliateAddress;&#13;
        }&#13;
&#13;
        restOfferAmount_ = restOfferAmount_.add(_leftAmount);&#13;
        if (currentOrder_.acceptAmount &gt; currentOrder_.acceptedAmount) {&#13;
            matching();&#13;
        }&#13;
&#13;
        playerOfferOrders_[offerInfo.playerAddress][players_[offerInfo.playerAddress].offeredCount] = offerInfo;&#13;
        players_[offerInfo.playerAddress].offeredCount = (players_[offerInfo.playerAddress].offeredCount).add(1);&#13;
&#13;
        if (players_[offerInfo.playerAddress].playerAddress == address(0)) {&#13;
            players_[offerInfo.playerAddress].playerAddress = offerInfo.playerAddress;&#13;
        }&#13;
    }&#13;
&#13;
    function matching() private {&#13;
        while (restOfferAmount_ &gt; 0 &amp;&amp; currentOrder_.acceptAmount &gt; currentOrder_.acceptedAmount) {&#13;
            uint256 needAcceptAmount = (currentOrder_.acceptAmount).sub(currentOrder_.acceptedAmount);&#13;
            if (needAcceptAmount &lt;= restOfferAmount_) { // currentOrder finished&#13;
                restOfferAmount_ = restOfferAmount_.sub(needAcceptAmount);&#13;
                players_[currentOrder_.playerAddress].balance = needAcceptAmount.add(players_[currentOrder_.playerAddress].balance);&#13;
                currentOrder_.acceptedAmount = (currentOrder_.acceptedAmount).add(needAcceptAmount);&#13;
                currentOrder_ = acceptOrders_[currentOrder_.nextOrder];&#13;
            } else { // offer end&#13;
                currentOrder_.acceptedAmount = (currentOrder_.acceptedAmount).add(restOfferAmount_);&#13;
                players_[currentOrder_.playerAddress].balance = (players_[currentOrder_.playerAddress].balance).add(restOfferAmount_);&#13;
                restOfferAmount_ = 0;&#13;
            }&#13;
        }&#13;
    }&#13;
&#13;
    function calcAndSetPlayerTotalCanAccept(address pAddr, uint256 acceptAmount) private {&#13;
        uint256 _now = block.timestamp;&#13;
        uint256 _latestCalced = players_[pAddr].lastCalcOfferNo;&#13;
        uint256 _acceptedAmount = acceptAmount;&#13;
&#13;
        while(_latestCalced &lt; players_[pAddr].offeredCount) {&#13;
            FMAPDatasets.OfferInfo storage oi = playerOfferOrders_[pAddr][_latestCalced];&#13;
            uint256 _ts = _now.sub(oi.timestamp);&#13;
            if (oi.interesting == true) {&#13;
                if (_ts &gt;= maxInterestTime_) {                    &#13;
                    // stop interesting...&#13;
                    uint256 interest1 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_); // 24 * 7&#13;
                    players_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest1);&#13;
                    oi.interesting = false;&#13;
&#13;
                    // set accept&#13;
                    if (oi.offerAmount.sub(oi.acceptAmount) &gt; _acceptedAmount) {&#13;
                        _acceptedAmount = 0;&#13;
                        oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);&#13;
                    } else {&#13;
                        _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));&#13;
                        oi.acceptAmount = oi.offerAmount;&#13;
                    }&#13;
                } else if (_acceptedAmount &gt; 0) {&#13;
                    if (_acceptedAmount &lt; oi.offerAmount.sub(oi.acceptAmount)) {&#13;
                        oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);&#13;
                        _acceptedAmount = 0;&#13;
                    } else {&#13;
                        uint256 interest0 = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(_ts / interestPeriod_);&#13;
                        players_[pAddr].canAccept = (players_[pAddr].canAccept).add(oi.offerAmount).add(interest0);&#13;
                        oi.interesting = false;&#13;
                        &#13;
                        _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));&#13;
                        oi.acceptAmount = oi.offerAmount;&#13;
            &#13;
                    }&#13;
                }&#13;
            } else if (oi.offerAmount &gt; oi.acceptAmount &amp;&amp; _acceptedAmount &gt; 0) {&#13;
                // set accept&#13;
                if (oi.offerAmount.sub(oi.acceptAmount) &gt; _acceptedAmount) {&#13;
                    _acceptedAmount = 0;&#13;
                    oi.acceptAmount = oi.acceptAmount.add(_acceptedAmount);&#13;
                } else {&#13;
                    _acceptedAmount = _acceptedAmount.sub(oi.offerAmount.sub(oi.acceptAmount));&#13;
                    oi.acceptAmount = oi.offerAmount;&#13;
                }&#13;
            }&#13;
            if (_acceptedAmount == 0) {&#13;
                break;&#13;
            }&#13;
            _latestCalced = _latestCalced + 1;&#13;
        }&#13;
        players_[pAddr].lastCalcOfferNo = _latestCalced;&#13;
    }&#13;
&#13;
    function airdrop() private view returns (bool) {&#13;
        uint256 seed = uint256(keccak256(abi.encodePacked(block.timestamp, block.number, block.timestamp, block.difficulty, block.gaslimit, airDropTracker_, block.coinbase, msg.sender)));&#13;
        if(seed - (seed / 10000).mul(10000) &lt; airDropTracker_) {&#13;
            return (true);&#13;
        }&#13;
        return (false);&#13;
    }&#13;
&#13;
    function calcCanAcceptAmount(address pAddr, bool isLimit, uint256 offsetTime) private view returns (uint256, uint256 nextUpdateTime) {&#13;
        uint256 _totalCanAccepted = players_[pAddr].canAccept;&#13;
        uint256 i = players_[pAddr].offeredCount;&#13;
        uint256 _now = block.timestamp.add(offsetTime);&#13;
        uint256 _nextUpdateTime = _now.add(interestPeriod_);&#13;
        for(;i &gt; 0; i--) {&#13;
            FMAPDatasets.OfferInfo memory oi = playerOfferOrders_[pAddr][i - 1];&#13;
            if (oi.interesting == true) {&#13;
                uint256 timepassed = _now.sub(oi.timestamp);&#13;
                if (!isLimit || (timepassed &gt;= interestPeriod_)) { // at least 1 period&#13;
                    uint256 interest;&#13;
                    if (timepassed &lt; maxInterestTime_) {&#13;
                        interest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(timepassed / interestPeriod_);&#13;
                        &#13;
                        uint256 oiNextUpdateTime = (timepassed / interestPeriod_).add(1).mul(interestPeriod_).add(oi.timestamp);&#13;
                        if (_nextUpdateTime &gt; oiNextUpdateTime) {&#13;
                            _nextUpdateTime = oiNextUpdateTime;&#13;
                        }&#13;
                    } else {&#13;
                        interest = oi.offerAmount.sub(oi.acceptAmount).mul(1).div(1000).mul(maxInterestTime_ / interestPeriod_);&#13;
                    }&#13;
                    _totalCanAccepted = _totalCanAccepted.add(oi.offerAmount).add(interest);&#13;
                }&#13;
            } else if (oi.timestamp == 0) {&#13;
                continue;&#13;
            } else {&#13;
                break;&#13;
            }&#13;
        }&#13;
&#13;
        return (_totalCanAccepted.sub(players_[pAddr].totalAccepted), _nextUpdateTime);&#13;
    }&#13;
&#13;
}&#13;
&#13;
//=========================================================...&#13;
//  _ _  _ _|_|_   |.|_  _ _  _   .&#13;
// | | |(_| | | |  |||_)| (_||\/  . math library&#13;
//============================/============================    &#13;
library FMAPMath {&#13;
    using SafeMath for uint256;&#13;
    function calcTrackerCount(uint256 ethAmount) internal pure returns (uint256) {&#13;
        if (ethAmount &gt;= 1 finney &amp;&amp; ethAmount &lt; 10 finney) {&#13;
            return (1);&#13;
        } else if (ethAmount &lt; 50 finney) {&#13;
            return (2);&#13;
        } else if (ethAmount &lt; 200 finney) {&#13;
            return (3);&#13;
        } else if (ethAmount &lt; 500 finney) {&#13;
            return (4);&#13;
        } else if (ethAmount &lt; 1 ether) {&#13;
            return (5);&#13;
        } else if (ethAmount &gt;= 1 ether) {&#13;
            return ethAmount.div(1 ether).add(5);&#13;
        }&#13;
        return (0);&#13;
    }&#13;
    function calcAirDropAmount(uint256 ethAmount) internal pure returns (uint256) {&#13;
        if (ethAmount &gt;= 1 finney &amp;&amp; ethAmount &lt; 10 finney) {&#13;
            return (5);&#13;
        } else if (ethAmount &lt; 50 finney) {&#13;
            return (10);&#13;
        } else if (ethAmount &lt; 200 finney) {&#13;
            return (15);&#13;
        } else if (ethAmount &lt; 500 finney) {&#13;
            return (20);&#13;
        } else if (ethAmount &lt; 1 ether) {&#13;
            return (25);&#13;
        } else if (ethAmount &gt;= 1 ether) {&#13;
            uint256 a = ethAmount.div(1 ether).add(5).mul(5);&#13;
            return (a &gt; 75 ? 75 : a);&#13;
        }&#13;
        return (0);&#13;
    }&#13;
}&#13;
//=========================================================...&#13;
//  __|_ _   __|_  .&#13;
// _\ | ||_|(_ |   .&#13;
//=========================================================&#13;
library FMAPDatasets {&#13;
    struct OfferInfo {&#13;
        address playerAddress;&#13;
        uint256 offerAmount;&#13;
        uint256 acceptAmount; // 不再计算利息&#13;
        address affiliateAddress;&#13;
        address siteOwner;&#13;
        uint256 timestamp;&#13;
        bool interesting;&#13;
    }&#13;
    struct AcceptOrder {&#13;
        uint256 orderId;&#13;
        address playerAddress;&#13;
        uint256 acceptAmount;&#13;
        uint256 acceptedAmount;&#13;
        uint256 nextOrder;&#13;
    }&#13;
    struct Player {&#13;
        address playerAddress;&#13;
        address lastAffiliate;&#13;
        uint256 totalOffered;&#13;
        uint256 totalAccepted;&#13;
        uint256 airDroped;&#13;
        uint256 balance; // can withdraw&#13;
        uint256 offeredCount;&#13;
        uint256 acceptOrderCount;&#13;
        uint256 canAccept;&#13;
        uint256 lastCalcOfferNo;&#13;
        uint256 affiliateEarned;&#13;
        uint256 siteEarned;&#13;
    }&#13;
}&#13;
&#13;
/**&#13;
 * @title SafeMath&#13;
 * @dev Math operations with safety checks that throw on error&#13;
 */&#13;
library SafeMath {&#13;
&#13;
    /**&#13;
    * @dev Multiplies two numbers, throws on overflow.&#13;
    */&#13;
    function mul(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
        // Gas optimization: this is cheaper than asserting 'a' not being zero, but the&#13;
        // benefit is lost if 'b' is also tested.&#13;
        // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522&#13;
        if (a == 0) {&#13;
            return 0;&#13;
        }&#13;
&#13;
        c = a * b;&#13;
        assert(c / a == b);&#13;
        return c;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Integer division of two numbers, truncating the quotient.&#13;
    */&#13;
    function div(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        // assert(b &gt; 0); // Solidity automatically throws when dividing by 0&#13;
        // uint256 c = a / b;&#13;
        // assert(a == b * c + a % b); // There is no case in which this doesn't hold&#13;
        return a / b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).&#13;
    */&#13;
    function sub(uint256 a, uint256 b) internal pure returns (uint256) {&#13;
        assert(b &lt;= a);&#13;
        return a - b;&#13;
    }&#13;
&#13;
    /**&#13;
    * @dev Adds two numbers, throws on overflow.&#13;
    */&#13;
    function add(uint256 a, uint256 b) internal pure returns (uint256 c) {&#13;
        c = a + b;&#13;
        assert(c &gt;= a);&#13;
        return c;&#13;
    }&#13;
}&#13;
&#13;
&#13;
/**&#13;
 * Utility library of inline functions on addresses&#13;
 */&#13;
library AddressUtils {&#13;
&#13;
    /**&#13;
    * Returns whether the target address is a contract&#13;
    * @dev This function will return false if invoked during the constructor of a contract,&#13;
    * as the code is not actually created until after the constructor finishes.&#13;
    * @param addr address to check&#13;
    * @return whether the target address is a contract&#13;
    */&#13;
    function isContract(address addr) internal view returns (bool) {&#13;
        uint256 size;&#13;
        // XXX Currently there is no better way to check if there is a contract in an address&#13;
        // than to check the size of the code at that address.&#13;
        // See https://ethereum.stackexchange.com/a/14016/36603&#13;
        // for more details about how this works.&#13;
        // TODO Check this again before the Serenity release, because all addresses will be&#13;
        // contracts then.&#13;
        // solium-disable-next-line security/no-inline-assembly&#13;
        assembly { size := extcodesize(addr) }&#13;
        return size &gt; 0;&#13;
    }&#13;
&#13;
}