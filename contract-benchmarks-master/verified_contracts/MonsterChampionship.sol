pragma solidity ^0.4.11;



contract Ownable {
  address public owner;


  /**
   * @dev The Ownable constructor sets the original `owner` of the contract to the sender
   * account.
   */
  function Ownable() public {
    owner = msg.sender;
  }


  /**
   * @dev Throws if called by any account other than the owner.
   */
  modifier onlyOwner() {
    require(msg.sender == owner);
    _;
  }


  /**
   * @dev Allows the current owner to transfer control of the contract to a newOwner.
   * @param newOwner The address to transfer ownership to.
   */
  function transferOwnership(address newOwner) public onlyOwner {
    if (newOwner != address(0)) {
      owner = newOwner;
    }
  }

}

/// @title Interface for contracts conforming to ERC-721: Non-Fungible Tokens
/// @author Dieter Shirley <<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="650100110025041d0c0a081f000b4b060a">[email protected]</a>&gt; (https://github.com/dete)&#13;
contract ERC721 {&#13;
    // Required methods&#13;
    function totalSupply() public view returns (uint256 total);&#13;
    function balanceOf(address _owner) public view returns (uint256 balance);&#13;
    function ownerOf(uint256 _tokenId) external view returns (address owner);&#13;
    function approve(address _to, uint256 _tokenId) external;&#13;
    function transfer(address _to, uint256 _tokenId) external;&#13;
    function transferFrom(address _from, address _to, uint256 _tokenId) external;&#13;
&#13;
    // Events&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
    event Approval(address owner, address approved, uint256 tokenId);&#13;
&#13;
    // Optional&#13;
    // function name() public view returns (string name);&#13;
    // function symbol() public view returns (string symbol);&#13;
    // function tokensOfOwner(address _owner) external view returns (uint256[] tokenIds);&#13;
    // function tokenMetadata(uint256 _tokenId, string _preferredTransport) public view returns (string infoUrl);&#13;
&#13;
    // ERC-165 Compatibility (https://github.com/ethereum/EIPs/issues/165)&#13;
    function supportsInterface(bytes4 _interfaceID) external view returns (bool);&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
&#13;
contract MonsterAccessControl {&#13;
&#13;
    event ContractUpgrade(address newContract);&#13;
&#13;
     // The addresses of the accounts (or contracts) that can execute actions within each roles.&#13;
    address public adminAddress;&#13;
    &#13;
&#13;
  &#13;
&#13;
    /// @dev Access modifier for CEO-only functionality&#13;
    modifier onlyAdmin() {&#13;
        require(msg.sender == adminAddress);&#13;
        _;&#13;
    }&#13;
&#13;
  &#13;
&#13;
    &#13;
}&#13;
&#13;
// This contract stores all data on the blockchain&#13;
// only our other contracts can interact with this&#13;
// the data here will be valid for all eternity even if other contracts get updated&#13;
// this way we can make sure that our Monsters have a hard-coded value attached to them&#13;
// that no one including us can change(!)&#13;
contract MonstersData {&#13;
&#13;
    address coreContract; // &#13;
    &#13;
&#13;
&#13;
    struct Monster {&#13;
        // timestamp of block when this monster was spawned/created&#13;
        uint64 birthTime;&#13;
&#13;
        // generation number&#13;
        // gen0 is the very first generation - the later monster spawn the less likely they are to have&#13;
        // special attributes and stats&#13;
       // uint16 generation;&#13;
&#13;
        uint16 hp; // health points &#13;
        uint16 attack; // attack points&#13;
        uint16 defense; // defense points&#13;
        uint16 spAttack; // special attack&#13;
        uint16 spDefense; // special defense&#13;
        uint16 speed; // speed responsible of who attacks first(!)&#13;
        &#13;
&#13;
        uint16 typeOne;&#13;
        uint16 typeTwo;&#13;
&#13;
        uint16 mID; // this id (from 1 to 151) is responsible for everything visually like showing the real deal!&#13;
        bool tradeable;&#13;
        //uint16 uID; // unique id&#13;
        &#13;
        // These attributes are handled by mappings since they would overflow the maximum stack&#13;
        //bool female&#13;
        // string nickname&#13;
        &#13;
&#13;
    }&#13;
&#13;
    // lv1 base stats&#13;
    struct MonsterBaseStats {&#13;
        uint16 hp;&#13;
        uint16 attack;&#13;
        uint16 defense;&#13;
        uint16 spAttack;&#13;
        uint16 spDefense;&#13;
        uint16 speed;&#13;
        &#13;
    }&#13;
&#13;
    // lomonsterion struct used for travelling around the "world"&#13;
    // &#13;
    struct Area {&#13;
        // areaID used in-engine to determine world position&#13;
       &#13;
             &#13;
        // minimum level to enter this area...&#13;
        uint16 minLevel;&#13;
    }&#13;
&#13;
    struct Trainer {&#13;
        // timestamp of block when this player/trainer was created&#13;
        uint64 birthTime;&#13;
        &#13;
        // add username&#13;
        string username;&#13;
       &#13;
        &#13;
        // current area in the "world"&#13;
        uint16 currArea;&#13;
        &#13;
        address owner;&#13;
        &#13;
       &#13;
        &#13;
    }&#13;
&#13;
&#13;
   &#13;
&#13;
&#13;
    // take timestamp of block this game was created on the blockchain&#13;
    uint64 creationBlock = uint64(now);&#13;
   &#13;
   &#13;
&#13;
   &#13;
  &#13;
    &#13;
&#13;
&#13;
    &#13;
  &#13;
        &#13;
&#13;
&#13;
}&#13;
&#13;
&#13;
&#13;
&#13;
contract MonstersBase is MonsterAccessControl, MonstersData {&#13;
&#13;
    /// @dev Transfer event as defined in current draft of ERC721. Emitted every time a monster&#13;
    ///  ownership is assigned, including births.&#13;
    event Transfer(address from, address to, uint256 tokenId);&#13;
&#13;
    bool lockedMonsterCreator = false;&#13;
&#13;
    MonsterAuction public monsterAuction;&#13;
&#13;
    MonsterCreatorInterface public monsterCreator;&#13;
&#13;
&#13;
    function setMonsterCreatorAddress(address _address) external onlyAdmin {&#13;
        // only set this once so we (the devs) can't cheat!&#13;
        require(!lockedMonsterCreator);&#13;
        MonsterCreatorInterface candidateContract = MonsterCreatorInterface(_address);&#13;
&#13;
       &#13;
&#13;
        monsterCreator = candidateContract;&#13;
        lockedMonsterCreator = true;&#13;
&#13;
    }&#13;
    &#13;
    // An approximation of currently how many seconds are in between blocks.&#13;
    uint256 public secondsPerBlock = 15;&#13;
  &#13;
&#13;
    // array containing all monsters in existence&#13;
    Monster[] monsters;&#13;
&#13;
    uint8[] areas;&#13;
&#13;
    uint8 areaIndex = 0;&#13;
    &#13;
&#13;
&#13;
      mapping(address =&gt; Trainer) public addressToTrainer;&#13;
    &#13;
&#13;
    /// @dev A mapping from monster IDs to the address that owns them. All monster have&#13;
    ///  some valid owner address, even gen0 monster are created with a non-zero owner.&#13;
    mapping (uint256 =&gt; address) public monsterIndexToOwner;&#13;
&#13;
    // @dev A mapping from owner address to count of tokens that address owns.&#13;
    //  Used internally inside balanceOf() to resolve ownership count.&#13;
    mapping (address =&gt; uint256) ownershipTokenCount;&#13;
&#13;
&#13;
    mapping (uint256 =&gt; address) public monsterIndexToApproved;&#13;
    &#13;
    mapping (uint256 =&gt; string) public monsterIdToNickname;&#13;
    &#13;
    mapping (uint256 =&gt; bool) public monsterIdToTradeable;&#13;
    &#13;
    mapping (uint256 =&gt; uint256) public monsterIdToGeneration;&#13;
&#13;
&#13;
     mapping (uint256 =&gt; MonsterBaseStats) public baseStats;&#13;
&#13;
     mapping (uint256 =&gt; uint8[7]) public monsterIdToIVs;&#13;
    &#13;
&#13;
&#13;
    // adds new area to world &#13;
    function _createArea() internal {&#13;
            &#13;
            areaIndex++;&#13;
            areas.push(areaIndex);&#13;
            &#13;
            &#13;
        }&#13;
&#13;
    &#13;
&#13;
&#13;
    function _createMonster(&#13;
        uint256 _generation,&#13;
        uint256 _hp,&#13;
        uint256 _attack,&#13;
        uint256 _defense,&#13;
        uint256 _spAttack,&#13;
        uint256 _spDefense,&#13;
        uint256 _speed,&#13;
        uint256 _typeOne,&#13;
        uint256 _typeTwo,&#13;
        address _owner,&#13;
        uint256 _mID,&#13;
        bool tradeable&#13;
        &#13;
    )&#13;
        internal&#13;
        returns (uint)&#13;
        {&#13;
           &#13;
&#13;
            Monster memory _monster = Monster({&#13;
                birthTime: uint64(now),&#13;
                hp: uint16(_hp),&#13;
                attack: uint16(_attack),&#13;
                defense: uint16(_defense),&#13;
                spAttack: uint16(_spAttack),&#13;
                spDefense: uint16(_spDefense),&#13;
                speed: uint16(_speed),&#13;
                typeOne: uint16(_typeOne),&#13;
                typeTwo: uint16(_typeTwo),&#13;
                mID: uint16(_mID),&#13;
                tradeable: tradeable&#13;
                &#13;
&#13;
&#13;
            });&#13;
            uint256 newMonsterId = monsters.push(_monster) - 1;&#13;
            monsterIdToTradeable[newMonsterId] = tradeable;&#13;
            monsterIdToGeneration[newMonsterId] = _generation;&#13;
           &#13;
&#13;
            require(newMonsterId == uint256(uint32(newMonsterId)));&#13;
            &#13;
           &#13;
          &#13;
            &#13;
             monsterIdToNickname[newMonsterId] = "";&#13;
&#13;
            _transfer(0, _owner, newMonsterId);&#13;
&#13;
            return newMonsterId;&#13;
&#13;
&#13;
        }&#13;
    &#13;
    function _createTrainer(string _username, uint16 _starterId, address _owner)&#13;
        internal&#13;
        returns (uint mon)&#13;
        {&#13;
            &#13;
           &#13;
            Trainer memory _trainer = Trainer({&#13;
               &#13;
                birthTime: uint64(now),&#13;
                username: string(_username),&#13;
                currArea: uint16(1), // sets to first area!,&#13;
                owner: address(_owner)&#13;
                &#13;
            });&#13;
            &#13;
            // starter stats are hardcoded!&#13;
            if (_starterId == 1) {&#13;
                uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(1));&#13;
                mon = _createMonster(0, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], _owner, 1, false);&#13;
               &#13;
            } else if (_starterId == 2) {&#13;
                uint8[8] memory Stats2 = uint8[8](monsterCreator.getMonsterStats(4));&#13;
                mon = _createMonster(0, Stats2[0], Stats2[1], Stats2[2], Stats2[3], Stats2[4], Stats2[5], Stats2[6], Stats2[7], _owner, 4, false);&#13;
                &#13;
            } else if (_starterId == 3) {&#13;
                uint8[8] memory Stats3 = uint8[8](monsterCreator.getMonsterStats(7));&#13;
                mon = _createMonster(0, Stats3[0], Stats3[1], Stats3[2], Stats3[3], Stats3[4], Stats3[5], Stats3[6], Stats3[7], _owner, 7, false);&#13;
                &#13;
            }&#13;
            &#13;
        }&#13;
&#13;
&#13;
    function _moveToArea(uint16 _newArea, address player) internal {&#13;
            &#13;
            addressToTrainer[player].currArea = _newArea;&#13;
          &#13;
        }   &#13;
        &#13;
    &#13;
     &#13;
&#13;
    &#13;
    // assigns ownership of monster to address&#13;
    function _transfer(address _from, address _to, uint256 _tokenId) internal {&#13;
        ownershipTokenCount[_to]++;&#13;
        monsterIndexToOwner[_tokenId] = _to;&#13;
&#13;
        if (_from != address(0)) {&#13;
            ownershipTokenCount[_from]--;&#13;
&#13;
            // clear any previously approved ownership exchange&#13;
            delete monsterIndexToApproved[_tokenId];&#13;
        }&#13;
&#13;
        // Emit Transfer event&#13;
        Transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
&#13;
    // Only admin can fix how many seconds per blocks are currently observed.&#13;
    function setSecondsPerBlock(uint256 secs) external onlyAdmin {&#13;
        //require(secs &lt; cooldowns[0]);&#13;
        secondsPerBlock = secs;&#13;
    }&#13;
&#13;
&#13;
    &#13;
&#13;
&#13;
}&#13;
&#13;
/// @title The external contract that is responsible for generating metadata for the monsters,&#13;
///  it has one function that will return the data as bytes.&#13;
contract ERC721Metadata {&#13;
    /// @dev Given a token Id, returns a byte array that is supposed to be converted into string.&#13;
    function getMetadata(uint256 _tokenId, string) public view returns (bytes32[4] buffer, uint256 count) {&#13;
        if (_tokenId == 1) {&#13;
            buffer[0] = "Hello World! :D";&#13;
            count = 15;&#13;
        } else if (_tokenId == 2) {&#13;
            buffer[0] = "I would definitely choose a medi";&#13;
            buffer[1] = "um length string.";&#13;
            count = 49;&#13;
        } else if (_tokenId == 3) {&#13;
            buffer[0] = "Lorem ipsum dolor sit amet, mi e";&#13;
            buffer[1] = "st accumsan dapibus augue lorem,";&#13;
            buffer[2] = " tristique vestibulum id, libero";&#13;
            buffer[3] = " suscipit varius sapien aliquam.";&#13;
            count = 128;&#13;
        }&#13;
    }&#13;
}&#13;
&#13;
&#13;
contract MonsterOwnership is MonstersBase, ERC721 {&#13;
&#13;
    string public constant name = "ChainMonsters";&#13;
    string public constant symbol = "CHMO";&#13;
&#13;
&#13;
    // The contract that will return monster metadata&#13;
    ERC721Metadata public erc721Metadata;&#13;
&#13;
    bytes4 constant InterfaceSignature_ERC165 =&#13;
        bytes4(keccak256('supportsInterface(bytes4)'));&#13;
&#13;
&#13;
&#13;
&#13;
    bytes4 constant InterfaceSignature_ERC721 =&#13;
        bytes4(keccak256('name()')) ^&#13;
        bytes4(keccak256('symbol()')) ^&#13;
        bytes4(keccak256('totalSupply()')) ^&#13;
        bytes4(keccak256('balanceOf(address)')) ^&#13;
        bytes4(keccak256('ownerOf(uint256)')) ^&#13;
        bytes4(keccak256('approve(address,uint256)')) ^&#13;
        bytes4(keccak256('transfer(address,uint256)')) ^&#13;
        bytes4(keccak256('transferFrom(address,address,uint256)')) ^&#13;
        bytes4(keccak256('tokensOfOwner(address)')) ^&#13;
        bytes4(keccak256('tokenMetadata(uint256,string)'));&#13;
&#13;
&#13;
&#13;
&#13;
    function supportsInterface(bytes4 _interfaceID) external view returns (bool) {&#13;
        // DEBUG ONLY&#13;
        //require((InterfaceSignature_ERC165 == 0x01ffc9a7) &amp;&amp; (InterfaceSignature_ERC721 == 0x9a20483d));&#13;
&#13;
        return ((_interfaceID == InterfaceSignature_ERC165) || (_interfaceID == InterfaceSignature_ERC721));&#13;
    }&#13;
&#13;
    /// @dev Set the address of the sibling contract that tracks metadata.&#13;
    ///  CEO only.&#13;
    function setMetadataAddress(address _contractAddress) public onlyAdmin {&#13;
        erc721Metadata = ERC721Metadata(_contractAddress);&#13;
    }&#13;
&#13;
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return monsterIndexToOwner[_tokenId] == _claimant;&#13;
    }&#13;
    &#13;
    function _isTradeable(uint256 _tokenId) external view returns (bool) {&#13;
        return monsterIdToTradeable[_tokenId];&#13;
    }&#13;
    &#13;
    &#13;
    /// @dev Checks if a given address currently has transferApproval for a particular monster.&#13;
    /// @param _claimant the address we are confirming monster is approved for.&#13;
    /// @param _tokenId monster id, only valid when &gt; 0&#13;
    function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return monsterIndexToApproved[_tokenId] == _claimant;&#13;
    }&#13;
&#13;
    /// @dev Marks an address as being approved for transferFrom(), overwriting any previous&#13;
    ///  approval. Setting _approved to address(0) clears all transfer approval.&#13;
    ///  NOTE: _approve() does NOT send the Approval event. This is intentional because&#13;
    ///  _approve() and transferFrom() are used together for putting monsters on auction, and&#13;
    ///  there is no value in spamming the log with Approval events in that case.&#13;
    function _approve(uint256 _tokenId, address _approved) internal {&#13;
        monsterIndexToApproved[_tokenId] = _approved;&#13;
    }&#13;
    &#13;
    &#13;
    function balanceOf(address _owner) public view returns (uint256 count) {&#13;
        return ownershipTokenCount[_owner];&#13;
    }&#13;
&#13;
&#13;
    function transfer (address _to, uint256 _tokenId) external {&#13;
        // Safety check to prevent against an unexpected 0x0 default.&#13;
        require(_to != address(0));&#13;
        // Disallow transfers to this contract to prevent accidental misuse.&#13;
        // The contract should never own any monsters (except very briefly&#13;
        // after a gen0 monster is created and before it goes on auction).&#13;
        require(_to != address(this));&#13;
        &#13;
&#13;
        // You can only send your own monster.&#13;
        require(_owns(msg.sender, _tokenId));&#13;
&#13;
        // Reassign ownership, clear pending approvals, emit Transfer event.&#13;
        _transfer(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    &#13;
    &#13;
&#13;
/// @notice Grant another address the right to transfer a specific monster via&#13;
    ///  transferFrom(). This is the preferred flow for transfering NFTs to contracts.&#13;
    /// @param _to The address to be granted transfer approval. Pass address(0) to&#13;
    ///  clear all approvals.&#13;
    /// @param _tokenId The ID of the monster that can be transferred if this call succeeds.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function approve(address _to, uint256 _tokenId ) external {&#13;
        // Only an owner can grant transfer approval.&#13;
        require(_owns(msg.sender, _tokenId));&#13;
&#13;
        // Register the approval (replacing any previous approval).&#13;
        _approve(_tokenId, _to);&#13;
&#13;
        // Emit approval event.&#13;
        Approval(msg.sender, _to, _tokenId);&#13;
    }&#13;
&#13;
    /// @notice Transfer a monster owned by another address, for which the calling address&#13;
    ///  has previously been granted transfer approval by the owner.&#13;
    /// @param _from The address that owns the monster to be transfered.&#13;
    /// @param _to The address that should take ownership of the monster. Can be any address,&#13;
    ///  including the caller.&#13;
    /// @param _tokenId The ID of the monster to be transferred.&#13;
    /// @dev Required for ERC-721 compliance.&#13;
    function transferFrom (address _from, address _to, uint256 _tokenId ) external {&#13;
        // Safety check to prevent against an unexpected 0x0 default.&#13;
        require(_to != address(0));&#13;
        // Disallow transfers to this contract to prevent accidental misuse.&#13;
        // The contract should never own any monsters (except very briefly&#13;
        // after a gen0 monster is created and before it goes on auction).&#13;
        require(_to != address(this));&#13;
        // Check for approval and valid ownership&#13;
        //require(_approvedFor(msg.sender, _tokenId));&#13;
        require(_owns(_from, _tokenId));&#13;
&#13;
        // Reassign ownership (also clears pending approvals and emits Transfer event).&#13;
        _transfer(_from, _to, _tokenId);&#13;
    }&#13;
&#13;
    function totalSupply() public view returns (uint) {&#13;
        return monsters.length;&#13;
    }&#13;
&#13;
&#13;
    function ownerOf(uint256 _tokenId)&#13;
            external&#13;
            view&#13;
            returns (address owner)&#13;
        {&#13;
            owner = monsterIndexToOwner[_tokenId];&#13;
&#13;
            require(owner != address(0));&#13;
        }&#13;
&#13;
     function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {&#13;
        uint256 tokenCount = balanceOf(_owner);&#13;
&#13;
        if (tokenCount == 0) {&#13;
            // Return an empty array&#13;
            return new uint256[](0);&#13;
        } else {&#13;
            uint256[] memory result = new uint256[](tokenCount);&#13;
            uint256 totalMonsters = totalSupply();&#13;
            uint256 resultIndex = 0;&#13;
&#13;
            &#13;
            uint256 monsterId;&#13;
&#13;
            for (monsterId = 0; monsterId &lt;= totalMonsters; monsterId++) {&#13;
                if (monsterIndexToOwner[monsterId] == _owner) {&#13;
                    result[resultIndex] = monsterId;&#13;
                    resultIndex++;&#13;
                }&#13;
            }&#13;
&#13;
            return result;&#13;
        }&#13;
    }&#13;
&#13;
&#13;
   &#13;
&#13;
    /// @dev Adapted from memcpy() by @arachnid (Nick Johnson &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="7b1a091a181315121f3b15140f1f140f55151e0f">[email protected]</a>&gt;)&#13;
    ///  This method is licenced under the Apache License.&#13;
    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol&#13;
    function _memcpy(uint _dest, uint _src, uint _len) private view {&#13;
        // Copy word-length chunks while possible&#13;
        for(; _len &gt;= 32; _len -= 32) {&#13;
            assembly {&#13;
                mstore(_dest, mload(_src))&#13;
            }&#13;
            _dest += 32;&#13;
            _src += 32;&#13;
        }&#13;
&#13;
        // Copy remaining bytes&#13;
        uint256 mask = 256 ** (32 - _len) - 1;&#13;
        assembly {&#13;
            let srcpart := and(mload(_src), not(mask))&#13;
            let destpart := and(mload(_dest), mask)&#13;
            mstore(_dest, or(destpart, srcpart))&#13;
        }&#13;
    }&#13;
&#13;
    /// @dev Adapted from toString(slice) by @arachnid (Nick Johnson &lt;<a href="/cdn-cgi/l/email-protection" class="__cf_email__" data-cfemail="c6a7b4a7a5aea8afa286a8a9b2a2a9b2e8a8a3b2">[email protected]</a>&gt;)&#13;
    ///  This method is licenced under the Apache License.&#13;
    ///  Ref: https://github.com/Arachnid/solidity-stringutils/blob/2f6ca9accb48ae14c66f1437ec50ed19a0616f78/strings.sol&#13;
    function _toString(bytes32[4] _rawBytes, uint256 _stringLength) private view returns (string) {&#13;
        var outputString = new string(_stringLength);&#13;
        uint256 outputPtr;&#13;
        uint256 bytesPtr;&#13;
&#13;
        assembly {&#13;
            outputPtr := add(outputString, 32)&#13;
            bytesPtr := _rawBytes&#13;
        }&#13;
&#13;
        _memcpy(outputPtr, bytesPtr, _stringLength);&#13;
&#13;
        return outputString;&#13;
    }&#13;
&#13;
    /// @notice Returns a URI pointing to a metadata package for this token conforming to&#13;
    ///  ERC-721 (https://github.com/ethereum/EIPs/issues/721)&#13;
    /// @param _tokenId The ID number of the monster whose metadata should be returned.&#13;
    function tokenMetadata(uint256 _tokenId, string _preferredTransport) external view returns (string infoUrl) {&#13;
        require(erc721Metadata != address(0));&#13;
        bytes32[4] memory buffer;&#13;
        uint256 count;&#13;
        (buffer, count) = erc721Metadata.getMetadata(_tokenId, _preferredTransport);&#13;
&#13;
        return _toString(buffer, count);&#13;
    }&#13;
&#13;
}&#13;
&#13;
contract MonsterAuctionBase {&#13;
    &#13;
    &#13;
    // Reference to contract tracking NFT ownership&#13;
    ERC721 public nonFungibleContract;&#13;
    ChainMonstersCore public core;&#13;
    &#13;
    struct Auction {&#13;
&#13;
        // current owner&#13;
        address seller;&#13;
&#13;
        // price in wei&#13;
        uint256 price;&#13;
&#13;
        // time when auction started&#13;
        uint64 startedAt;&#13;
&#13;
        uint256 id;&#13;
    }&#13;
&#13;
  &#13;
&#13;
    // Cut owner takes on each auction, measured in basis points (1/100 of a percent).&#13;
    // Values 0-10,000 map to 0%-100%&#13;
    uint256 public ownerCut;&#13;
&#13;
    // Map from token ID to their corresponding auction.&#13;
    mapping(uint256 =&gt; Auction) tokenIdToAuction;&#13;
&#13;
    mapping(uint256 =&gt; address) public auctionIdToSeller;&#13;
    &#13;
    mapping (address =&gt; uint256) public ownershipAuctionCount;&#13;
&#13;
&#13;
    event AuctionCreated(uint256 tokenId, uint256 price, uint256 uID, address seller);&#13;
    event AuctionSuccessful(uint256 tokenId, uint256 price, address newOwner, uint256 uID);&#13;
    event AuctionCancelled(uint256 tokenId, uint256 uID);&#13;
&#13;
&#13;
    function _transfer(address _receiver, uint256 _tokenId) internal {&#13;
        // it will throw if transfer fails&#13;
        nonFungibleContract.transfer(_receiver, _tokenId);&#13;
    }&#13;
&#13;
&#13;
    function _addAuction(uint256 _tokenId, Auction _auction) internal {&#13;
        &#13;
        tokenIdToAuction[_tokenId] = _auction;&#13;
&#13;
        AuctionCreated(&#13;
            uint256(_tokenId),&#13;
            uint256(_auction.price),&#13;
            uint256(_auction.id),&#13;
            address(_auction.seller)&#13;
        );&#13;
       &#13;
    }&#13;
&#13;
&#13;
    function _cancelAuction(uint256 _tokenId, address _seller) internal {&#13;
        &#13;
        Auction storage _auction = tokenIdToAuction[_tokenId];&#13;
&#13;
        uint256 uID = _auction.id;&#13;
        &#13;
        _removeAuction(_tokenId);&#13;
        ownershipAuctionCount[_seller]--;&#13;
        _transfer(_seller, _tokenId);&#13;
        &#13;
        AuctionCancelled(_tokenId, uID);&#13;
    }&#13;
&#13;
&#13;
    function _buy(uint256 _tokenId, uint256 _bidAmount)&#13;
        internal&#13;
        returns (uint256)&#13;
        {&#13;
            Auction storage auction = tokenIdToAuction[_tokenId];&#13;
        &#13;
&#13;
        require(_isOnAuction(auction));&#13;
&#13;
        uint256 price = auction.price;&#13;
        require(_bidAmount &gt;= price);&#13;
&#13;
        address seller = auction.seller;&#13;
&#13;
        uint256 uID = auction.id;&#13;
        // Auction Bid looks fine! so remove&#13;
        _removeAuction(_tokenId);&#13;
        ownershipAuctionCount[seller]--;&#13;
&#13;
        if (price &gt; 0) {&#13;
&#13;
            uint256 auctioneerCut = _computeCut(price);&#13;
            uint256 sellerProceeds = price - auctioneerCut;&#13;
&#13;
            // NOTE: Doing a transfer() in the middle of a complex&#13;
            // method like this is generally discouraged because of&#13;
            // reentrancy attacks and DoS attacks if the seller is&#13;
            // a contract with an invalid fallback function. We explicitly&#13;
            // guard against reentrancy attacks by removing the auction&#13;
            // before calling transfer(), and the only thing the seller&#13;
            // can DoS is the sale of their own asset! (And if it's an&#13;
            // accident, they can call cancelAuction(). )&#13;
            if(seller != address(core)) {&#13;
                seller.transfer(sellerProceeds);&#13;
            }&#13;
        }&#13;
&#13;
        // Calculate any excess funds included with the bid. If the excess&#13;
        // is anything worth worrying about, transfer it back to bidder.&#13;
        // NOTE: We checked above that the bid amount is greater than or&#13;
        // equal to the price so this cannot underflow.&#13;
        uint256 bidExcess = _bidAmount - price;&#13;
&#13;
        // Return the funds. Similar to the previous transfer, this is&#13;
        // not susceptible to a re-entry attack because the auction is&#13;
        // removed before any transfers occur.&#13;
        msg.sender.transfer(bidExcess);&#13;
&#13;
        // Tell the world!&#13;
        AuctionSuccessful(_tokenId, price, msg.sender, uID);&#13;
&#13;
        return price;&#13;
&#13;
&#13;
    }&#13;
&#13;
    function _removeAuction(uint256 _tokenId) internal {&#13;
        delete tokenIdToAuction[_tokenId];&#13;
    }&#13;
&#13;
    function _isOnAuction(Auction storage _auction) internal view returns (bool) {&#13;
        return (_auction.startedAt &gt; 0);&#13;
    }&#13;
&#13;
     function _computeCut(uint256 _price) internal view returns (uint256) {&#13;
        // NOTE: We don't use SafeMath (or similar) in this function because&#13;
        //  all of our entry functions carefully cap the maximum values for&#13;
        //  currency (at 128-bits), and ownerCut &lt;= 10000 (see the require()&#13;
        //  statement in the ClockAuction constructor). The result of this&#13;
        //  function is always guaranteed to be &lt;= _price.&#13;
        return _price * ownerCut / 10000;&#13;
    }&#13;
&#13;
    &#13;
&#13;
}&#13;
&#13;
&#13;
contract MonsterAuction is  MonsterAuctionBase, Ownable {&#13;
&#13;
&#13;
    bool public isMonsterAuction = true;&#13;
     uint256 public auctionIndex = 0;&#13;
&#13;
    /// @dev The ERC-165 interface signature for ERC-721.&#13;
    ///  Ref: https://github.com/ethereum/EIPs/issues/165&#13;
    ///  Ref: https://github.com/ethereum/EIPs/issues/721&#13;
    bytes4 constant InterfaceSignature_ERC721 = bytes4(0x9a20483d);&#13;
&#13;
    function MonsterAuction(address _nftAddress, uint256 _cut) public {&#13;
        require(_cut &lt;= 10000);&#13;
        ownerCut = _cut;&#13;
&#13;
        ERC721 candidateContract = ERC721(_nftAddress);&#13;
        &#13;
        nonFungibleContract = candidateContract;&#13;
        ChainMonstersCore candidateCoreContract = ChainMonstersCore(_nftAddress);&#13;
        core = candidateCoreContract;&#13;
&#13;
        &#13;
    }&#13;
    &#13;
    // only possible to decrease ownerCut!&#13;
    function setOwnerCut(uint256 _cut) external onlyOwner {&#13;
        require(_cut &lt;= ownerCut);&#13;
        ownerCut = _cut;&#13;
    }&#13;
    &#13;
    &#13;
    function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {&#13;
        return (nonFungibleContract.ownerOf(_tokenId) == _claimant);&#13;
    }&#13;
    &#13;
    function _escrow(address _owner, uint256 _tokenId) internal {&#13;
        // it will throw if transfer fails&#13;
        nonFungibleContract.transferFrom(_owner, this, _tokenId);&#13;
    }&#13;
&#13;
    function withdrawBalance() external onlyOwner {&#13;
       &#13;
       &#13;
       uint256 balance = this.balance;&#13;
       &#13;
       &#13;
        owner.transfer(balance);&#13;
&#13;
        &#13;
       &#13;
    }&#13;
&#13;
    &#13;
    function tokensInAuctionsOfOwner(address _owner) external view returns(uint256[] auctionTokens) {&#13;
        &#13;
           uint256 numAuctions = ownershipAuctionCount[_owner];&#13;
&#13;
            &#13;
        &#13;
            uint256[] memory result = new uint256[](numAuctions);&#13;
            uint256 totalAuctions = core.totalSupply();&#13;
            uint256 resultIndex = 0;&#13;
&#13;
            &#13;
            uint256 auctionId;&#13;
&#13;
            for (auctionId = 0; auctionId &lt;= totalAuctions; auctionId++) {&#13;
                &#13;
                Auction storage auction = tokenIdToAuction[auctionId];&#13;
                if (auction.seller == _owner) {&#13;
                    &#13;
                    result[resultIndex] = auctionId;&#13;
                    resultIndex++;&#13;
                }&#13;
            }&#13;
&#13;
            return result;&#13;
        &#13;
        &#13;
    }&#13;
&#13;
&#13;
&#13;
&#13;
    function createAuction(uint256 _tokenId, uint256 _price, address _seller) external {&#13;
             require(_price == uint256(_price));&#13;
            require(core._isTradeable(_tokenId));&#13;
             require(_owns(msg.sender, _tokenId));&#13;
             _escrow(msg.sender, _tokenId);&#13;
&#13;
            &#13;
&#13;
            &#13;
             Auction memory auction = Auction(&#13;
                 _seller,&#13;
                 uint256(_price),&#13;
                 uint64(now),&#13;
                 uint256(auctionIndex)&#13;
             );&#13;
&#13;
            auctionIdToSeller[auctionIndex] = _seller;&#13;
            ownershipAuctionCount[_seller]++;&#13;
            &#13;
             auctionIndex++;&#13;
             _addAuction(_tokenId, auction);&#13;
        }&#13;
&#13;
    function buy(uint256 _tokenId) external payable {&#13;
            //delete auctionIdToSeller[_tokenId];&#13;
            // buy will throw if the bid or funds transfer fails&#13;
            _buy (_tokenId, msg.value);&#13;
            _transfer(msg.sender, _tokenId);&#13;
            &#13;
            &#13;
        }&#13;
&#13;
    &#13;
    function cancelAuction(uint256 _tokenId) external {&#13;
            Auction storage auction = tokenIdToAuction[_tokenId];&#13;
            require(_isOnAuction(auction));&#13;
&#13;
            address seller = auction.seller;&#13;
            require(msg.sender == seller);&#13;
            &#13;
            &#13;
            _cancelAuction(_tokenId, seller);&#13;
        }&#13;
&#13;
    &#13;
    function getAuction(uint256 _tokenId)&#13;
        external&#13;
        view&#13;
        returns&#13;
        (&#13;
            address seller,&#13;
            uint256 price,&#13;
            uint256 startedAt&#13;
        ) {&#13;
            Auction storage auction = tokenIdToAuction[_tokenId];&#13;
            require(_isOnAuction(auction));&#13;
&#13;
            return (&#13;
                auction.seller,&#13;
                auction.price,&#13;
                auction.startedAt&#13;
            );&#13;
        }&#13;
&#13;
&#13;
    function getPrice(uint256 _tokenId)&#13;
        external&#13;
        view&#13;
        returns (uint256)&#13;
        {&#13;
            Auction storage auction = tokenIdToAuction[_tokenId];&#13;
            require(_isOnAuction(auction));&#13;
            return auction.price;&#13;
        }&#13;
}&#13;
&#13;
&#13;
contract ChainMonstersAuction is MonsterOwnership {&#13;
&#13;
  &#13;
&#13;
&#13;
    function setMonsterAuctionAddress(address _address) external onlyAdmin {&#13;
        MonsterAuction candidateContract = MonsterAuction(_address);&#13;
&#13;
        require(candidateContract.isMonsterAuction());&#13;
&#13;
        monsterAuction = candidateContract;&#13;
    }&#13;
&#13;
&#13;
&#13;
    uint256 public constant PROMO_CREATION_LIMIT = 5000;&#13;
&#13;
    uint256 public constant GEN0_CREATION_LIMIT = 5000;&#13;
&#13;
    // Counts the number of monster the contract owner has created.&#13;
    uint256 public promoCreatedCount;&#13;
    uint256 public gen0CreatedCount;&#13;
&#13;
&#13;
    &#13;
    // its stats are completely dependent on the spawn alghorithm&#13;
    function createPromoMonster(uint256 _mId, address _owner) external onlyAdmin {&#13;
       &#13;
&#13;
       // during generation we have to keep in mind that we have only 10,000 tokens available&#13;
       // which have to be divided by 151 monsters, some rarer than others&#13;
       // see WhitePaper for gen0/promo monster plan&#13;
        &#13;
        require(promoCreatedCount &lt; PROMO_CREATION_LIMIT);&#13;
&#13;
        promoCreatedCount++;&#13;
        uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(uint256(_mId)));&#13;
        uint8[7] memory IVs = uint8[7](monsterCreator.getGen0IVs());&#13;
        &#13;
        uint256 monsterId = _createMonster(0, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], _owner, _mId, true);&#13;
        monsterIdToTradeable[monsterId] = true;&#13;
&#13;
        monsterIdToIVs[monsterId] = IVs;&#13;
        &#13;
       &#13;
    }&#13;
&#13;
   &#13;
&#13;
&#13;
    function createGen0Auction(uint256 _mId, uint256 price) external onlyAdmin {&#13;
        require(gen0CreatedCount &lt; GEN0_CREATION_LIMIT);&#13;
&#13;
        uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(uint256(_mId)));&#13;
        uint8[7] memory IVs = uint8[7](monsterCreator.getGen0IVs());&#13;
        uint256 monsterId = _createMonster(0, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], this, _mId, true);&#13;
        monsterIdToTradeable[monsterId] = true;&#13;
&#13;
        monsterIdToIVs[monsterId] = IVs;&#13;
&#13;
        monsterAuction.createAuction(monsterId, price, address(this));&#13;
&#13;
&#13;
        gen0CreatedCount++;&#13;
        &#13;
    }&#13;
&#13;
    &#13;
}&#13;
&#13;
&#13;
// used during launch for world championship&#13;
// can and will be upgraded during development with new battle system!&#13;
// this is just to give players something to do and test their monsters&#13;
// also demonstrates how we can build up more mechanics on top of our locked core contract!&#13;
contract MonsterChampionship is Ownable {&#13;
&#13;
    bool public isMonsterChampionship = true;&#13;
    &#13;
    ChainMonstersCore core;&#13;
    &#13;
    // list of top ten &#13;
    address[10] topTen;&#13;
&#13;
    // holds the address current "world" champion&#13;
    address public currChampion;&#13;
    &#13;
    &#13;
    mapping (address =&gt; uint256) public addressToPowerlevel;&#13;
    mapping (uint256 =&gt; address) public rankToAddress;&#13;
    &#13;
&#13;
   &#13;
    &#13;
    &#13;
     // try to beat every other player in the top10 with your strongest monster!&#13;
    // effectively looping through all top10 players, beating them one by one &#13;
    // and if strong enough placing your in the top10 as well&#13;
    function contestChampion(uint256 _tokenId) external {&#13;
            uint maxIndex = 9;&#13;
            &#13;
           &#13;
            &#13;
           &#13;
            &#13;
            // fail tx if player is already champion!&#13;
            // in theory players could increase their powerlevel by contesting themselves but&#13;
            // this check stops that from happening so other players have the chance to&#13;
            // become the temporary champion!&#13;
            if (currChampion == msg.sender)&#13;
                revert();&#13;
                &#13;
            &#13;
           require(core.isTrainer(msg.sender));        &#13;
           require(core.monsterIndexToOwner(_tokenId) == msg.sender);&#13;
            &#13;
           &#13;
           uint myPowerlevel = core.getMonsterPowerLevel(_tokenId);&#13;
&#13;
           &#13;
           // checks if this transaction is useless&#13;
           // since we can't fight against ourself!&#13;
           // also stops reentrancy attacks&#13;
           require(myPowerlevel &gt; addressToPowerlevel[msg.sender]);&#13;
           &#13;
          &#13;
           uint myRank = 0;&#13;
            &#13;
            for (uint i=0; i&lt;=maxIndex; i++) {&#13;
                //if (addres)&#13;
                if ( myPowerlevel &gt; addressToPowerlevel[topTen[i]] ) {&#13;
                    // you have beaten this one so increase temporary rank&#13;
                    myRank = i;&#13;
                    &#13;
                    if (myRank == maxIndex) {&#13;
                        currChampion = msg.sender;&#13;
                    }&#13;
                    &#13;
                    &#13;
                    &#13;
                    &#13;
                }&#13;
               &#13;
                &#13;
                &#13;
               &#13;
               &#13;
            }&#13;
            &#13;
            addressToPowerlevel[msg.sender] = myPowerlevel;&#13;
            &#13;
            address[10] storage newTopTen = topTen;&#13;
            &#13;
            if (currChampion == msg.sender) {&#13;
                for (uint j=0; j&lt;maxIndex; j++) {&#13;
                    // remove ourselves from this list in case &#13;
                    if (newTopTen[j] == msg.sender) {&#13;
                        newTopTen[j] = 0x0;&#13;
                        break;&#13;
                    }&#13;
                    &#13;
                }&#13;
            }&#13;
            &#13;
            &#13;
            for (uint x=0; x&lt;=myRank; x++) {&#13;
                if (x == myRank) {&#13;
                    &#13;
                   &#13;
                    newTopTen[x] = msg.sender;&#13;
                } else {&#13;
                    if (x &lt; maxIndex)&#13;
                        newTopTen[x] = topTen[x+1];    &#13;
                }&#13;
                &#13;
                &#13;
            }&#13;
            &#13;
            &#13;
            topTen = newTopTen;&#13;
            &#13;
        }&#13;
    &#13;
    &#13;
    &#13;
    function getTopPlayers()&#13;
        external&#13;
        view&#13;
        returns (&#13;
            address[10] players&#13;
        ) {&#13;
            players = topTen;&#13;
        }&#13;
    &#13;
&#13;
&#13;
&#13;
    &#13;
    &#13;
    &#13;
    &#13;
    function MonsterChampionship(address coreContract) public {&#13;
       core = ChainMonstersCore(coreContract);&#13;
    }&#13;
    &#13;
    function withdrawBalance() external onlyOwner {&#13;
       &#13;
        uint256 balance = this.balance;&#13;
       &#13;
       &#13;
        owner.transfer(balance);&#13;
        &#13;
    }&#13;
&#13;
&#13;
&#13;
&#13;
}&#13;
&#13;
&#13;
// where the not-so-much "hidden" magic happens&#13;
contract MonsterCreatorInterface is Ownable {&#13;
&#13;
    uint8 public lockedMonsterStatsCount = 0;&#13;
    uint nonce = 0;&#13;
&#13;
    function rand(uint8 min, uint8 max) public returns (uint8) {&#13;
        nonce++;&#13;
        uint8 result = (uint8(sha3(block.blockhash(block.number-1), nonce ))%max);&#13;
        &#13;
        if (result &lt; min)&#13;
        {&#13;
            result = result+min;&#13;
        }&#13;
        return result;&#13;
    }&#13;
    &#13;
    &#13;
&#13;
&#13;
    function shinyRand(uint16 min, uint16 max) public returns (uint16) {&#13;
        nonce++;&#13;
        uint16 result = (uint16(sha3(block.blockhash(block.number-1), nonce ))%max);&#13;
        &#13;
        if (result &lt; min)&#13;
        {&#13;
            result = result+min;&#13;
        }&#13;
        return result;&#13;
    }&#13;
    &#13;
    &#13;
    &#13;
    mapping(uint256 =&gt; uint8[8]) public baseStats;&#13;
&#13;
    function addBaseStats(uint256 _mId, uint8[8] data) external onlyOwner {&#13;
        // lock" the stats down forever&#13;
        // since hp is never going to be 0 this is a valid check&#13;
        // so we have to be extra careful when adding new baseStats!&#13;
        require(data[0] &gt; 0);&#13;
        require(baseStats[_mId][0] == 0);&#13;
        baseStats[_mId] = data;&#13;
    }&#13;
    &#13;
    function _addBaseStats(uint256 _mId, uint8[8] data) internal {&#13;
        &#13;
        &#13;
        baseStats[_mId] = data;&#13;
        lockedMonsterStatsCount++;&#13;
    }&#13;
&#13;
&#13;
    &#13;
&#13;
&#13;
    &#13;
    function MonsterCreatorInterface() public {&#13;
        &#13;
       // these monsters are already down and "locked" down stats/design wise&#13;
        _addBaseStats(1, [45, 49, 49, 65, 65, 45, 12, 4]);&#13;
        _addBaseStats(2, [60, 62, 63, 80, 80, 60, 12, 4]);&#13;
        _addBaseStats(3, [80, 82, 83, 100, 100, 80, 12, 4]);&#13;
        _addBaseStats(4, [39, 52, 43, 60, 50, 65, 10, 6]);&#13;
        _addBaseStats(5, [58, 64, 58, 80, 65, 80, 10, 6]);&#13;
        _addBaseStats(6, [78, 84, 78, 109, 85, 100, 10, 6]);&#13;
        _addBaseStats(7, [44, 48, 65, 50, 64, 43, 11, 14]);&#13;
        _addBaseStats(8, [59, 63, 80, 65, 80, 58, 11, 14]);&#13;
        _addBaseStats(9, [79, 83, 100, 85, 105, 78, 11, 14]);&#13;
        _addBaseStats(10, [40, 35, 30, 20, 20, 50, 7, 4]);&#13;
        &#13;
        _addBaseStats(149, [55, 50, 45, 135, 95, 120, 8, 14]);&#13;
        _addBaseStats(150, [91, 134, 95, 100, 100, 80, 2, 5]);&#13;
        _addBaseStats(151, [100, 100, 100, 100, 100, 100, 5, 19]);&#13;
    }&#13;
    &#13;
    // this serves as a lookup for new monsters to be generated since all monsters &#13;
    // of the same id share the base stats&#13;
    function getMonsterStats( uint256 _mID) external constant returns(uint8[8] stats) {&#13;
           stats[0] = baseStats[_mID][0];&#13;
           stats[1] = baseStats[_mID][1];&#13;
           stats[2] = baseStats[_mID][2];&#13;
           stats[3] = baseStats[_mID][3];&#13;
           stats[4] = baseStats[_mID][4];&#13;
           stats[5] = baseStats[_mID][5];&#13;
           stats[6] = baseStats[_mID][6];&#13;
           stats[7] = baseStats[_mID][7];&#13;
           &#13;
          &#13;
&#13;
        }&#13;
&#13;
        // generates randomized IVs for a new monster&#13;
        function getMonsterIVs() external returns(uint8[7] ivs) {&#13;
&#13;
            bool shiny = false;&#13;
&#13;
            uint16 chance = shinyRand(1, 8192);&#13;
&#13;
            if (chance == 42) {&#13;
                shiny = true;&#13;
            }&#13;
&#13;
            // IVs range between 0 and 31&#13;
            // stat range modified for shiny monsters!&#13;
            if (shiny == true) {&#13;
                ivs[0] = uint8(rand(10, 31));&#13;
                ivs[1] = uint8(rand(10, 31));&#13;
                ivs[2] = uint8(rand(10, 31));&#13;
                ivs[3] = uint8(rand(10, 31));&#13;
                ivs[4] = uint8(rand(10, 31));&#13;
                ivs[5] = uint8(rand(10, 31));&#13;
                ivs[6] = 1;&#13;
                &#13;
            } else {&#13;
                ivs[0] = uint8(rand(0, 31));&#13;
                ivs[1] = uint8(rand(0, 31));&#13;
                ivs[2] = uint8(rand(0, 31));&#13;
                ivs[3] = uint8(rand(0, 31));&#13;
                ivs[4] = uint8(rand(0, 31));&#13;
                ivs[5] = uint8(rand(0, 31));&#13;
                ivs[6] = 0;&#13;
            }&#13;
&#13;
            &#13;
&#13;
        }&#13;
&#13;
&#13;
        // gen0 monsters profit from shiny boost while shiny gen0s have potentially even higher IVs!&#13;
        // further increasing the rarity by also doubling the shiny chance!&#13;
        function getGen0IVs() external returns (uint8[7] ivs) {&#13;
            &#13;
            bool shiny = false;&#13;
&#13;
            uint16 chance = shinyRand(1, 4096);&#13;
&#13;
            if (chance == 42) {&#13;
                shiny = true;&#13;
            }&#13;
            &#13;
            if (shiny) {&#13;
                 ivs[0] = uint8(rand(15, 31));&#13;
                ivs[1] = uint8(rand(15, 31));&#13;
                ivs[2] = uint8(rand(15, 31));&#13;
                ivs[3] = uint8(rand(15, 31));&#13;
                ivs[4] = uint8(rand(15, 31));&#13;
                ivs[5] = uint8(rand(15, 31));&#13;
                ivs[6] = 1;&#13;
                &#13;
            } else {&#13;
                ivs[0] = uint8(rand(10, 31));&#13;
                ivs[1] = uint8(rand(10, 31));&#13;
                ivs[2] = uint8(rand(10, 31));&#13;
                ivs[3] = uint8(rand(10, 31));&#13;
                ivs[4] = uint8(rand(10, 31));&#13;
                ivs[5] = uint8(rand(10, 31));&#13;
                ivs[6] = 0;&#13;
            }&#13;
            &#13;
        }&#13;
        &#13;
        function withdrawBalance() external onlyOwner {&#13;
       &#13;
        uint256 balance = this.balance;&#13;
       &#13;
       &#13;
        owner.transfer(balance);&#13;
        &#13;
    }&#13;
}&#13;
&#13;
contract GameLogicContract {&#13;
    &#13;
    bool public isGameLogicContract = true;&#13;
    &#13;
    function GameLogicContract() public {&#13;
        &#13;
    }&#13;
}&#13;
&#13;
contract ChainMonstersCore is ChainMonstersAuction, Ownable {&#13;
&#13;
&#13;
   // using a bool to enable us to prepare the game &#13;
   bool hasLaunched = false;&#13;
&#13;
&#13;
    // this address will hold future gamelogic in place&#13;
    address gameContract;&#13;
    &#13;
&#13;
    function ChainMonstersCore() public {&#13;
&#13;
        adminAddress = msg.sender;&#13;
        &#13;
&#13;
        _createArea(); // area 1&#13;
        _createArea(); // area 2&#13;
        &#13;
    &#13;
&#13;
        &#13;
    }&#13;
    &#13;
    // we don't know the exact interfaces yet so use the lockedMonsterStats value to determine if the game is "ready"&#13;
    // see WhitePaper for explaination for our upgrade and development roadmap&#13;
    function setGameLogicContract(address _candidateContract) external onlyOwner {&#13;
        require(monsterCreator.lockedMonsterStatsCount() == 151);&#13;
        &#13;
        require(GameLogicContract(_candidateContract).isGameLogicContract());&#13;
        gameContract = _candidateContract;&#13;
    }&#13;
&#13;
    // only callable by gameContract after the full game is launched&#13;
    // since all additional monsters after the promo/gen0 ones need to use this coreContract&#13;
    // contract as well we have to prepare this core for our future updates where&#13;
    // players can freely roam the world and hunt ChainMonsters thus generating more&#13;
    function spawnMonster(uint256 _mId, address _owner) external {&#13;
         &#13;
        require(msg.sender == gameContract);&#13;
        &#13;
        uint8[8] memory Stats = uint8[8](monsterCreator.getMonsterStats(uint256(_mId)));&#13;
        uint8[7] memory IVs = uint8[7](monsterCreator.getMonsterIVs());&#13;
        &#13;
        // important to note that the IV generators do not use Gen0 methods and are Generation 1 &#13;
        // this means there won't be more than the 10,000 Gen0 monsters sold during the development through the marketplace&#13;
        uint256 monsterId = _createMonster(1, Stats[0], Stats[1], Stats[2], Stats[3], Stats[4], Stats[5], Stats[6], Stats[7], _owner, _mId, true);&#13;
        monsterIdToTradeable[monsterId] = true;&#13;
&#13;
        monsterIdToIVs[monsterId] = IVs;&#13;
    }&#13;
    &#13;
    &#13;
    // used to add playable content to the game &#13;
    // monsters will only spawn in certain areas so some are locked on release&#13;
    // due to the game being in active development on "launch"&#13;
    // each monster has a maximum number of 3 areas where it can appear&#13;
    // &#13;
     function createArea() public onlyAdmin {&#13;
            _createArea();&#13;
        }&#13;
&#13;
    function createTrainer(string _username, uint16 _starterId) public {&#13;
            &#13;
            require(hasLaunched);&#13;
&#13;
            // only one trainer/account per ethereum address&#13;
            require(addressToTrainer[msg.sender].owner == 0);&#13;
           &#13;
           // valid input check&#13;
            require(_starterId == 1 || _starterId == 2 || _starterId == 3 );&#13;
            &#13;
            uint256 mon = _createTrainer(_username, _starterId, msg.sender);&#13;
            &#13;
            // due to stack limitations we have to assign the IVs here:&#13;
            uint8[7] memory IVs = uint8[7](monsterCreator.getMonsterIVs());&#13;
            monsterIdToIVs[mon] = IVs;&#13;
            &#13;
        }&#13;
        &#13;
        &#13;
    function changeUsername(string _name) public {&#13;
            require(addressToTrainer[msg.sender].owner == msg.sender);&#13;
            &#13;
            &#13;
            addressToTrainer[msg.sender].username = _name;&#13;
        }&#13;
        &#13;
    function changeMonsterNickname(uint256 _tokenId, string _name) public {&#13;
            // users won't be able to rename a monster that is part of an auction&#13;
            require(_owns(msg.sender, _tokenId));&#13;
            &#13;
            &#13;
            // some string checks...?&#13;
            monsterIdToNickname[_tokenId] = _name;&#13;
        }&#13;
&#13;
    function moveToArea(uint16 _newArea) public {&#13;
           &#13;
            // never allow anyone to move to area 0 or below since this is used&#13;
            // to determine if a trainer profile exists in another method!&#13;
            require(_newArea &gt; 0);&#13;
            &#13;
            // make sure that this area exists yet!&#13;
            require(areas.length &gt;= _newArea);&#13;
             &#13;
            // when player is not stuck doing something else he can move freely!&#13;
            _moveToArea(_newArea, msg.sender);&#13;
        }&#13;
&#13;
    &#13;
    // to be changed to retrieve current stats!&#13;
    function getMonster(uint256 _id) external view returns (&#13;
        uint256 birthTime,&#13;
        uint256 generation,&#13;
        uint256 hp,&#13;
        uint256 attack,&#13;
        uint256 defense,&#13;
        uint256 spAttack,&#13;
        uint256 spDefense,&#13;
        uint256 speed,&#13;
        uint256 typeOne,&#13;
        uint256 typeTwo,&#13;
        &#13;
        uint256 mID,&#13;
        bool tradeable, &#13;
        uint256 uID&#13;
        &#13;
            &#13;
        ) {    &#13;
       Monster storage mon = monsters[_id];&#13;
        birthTime = uint256(mon.birthTime);&#13;
        generation = 0; // hardcoding due to stack too deep error&#13;
        hp = uint256(mon.hp);&#13;
        attack = uint256(mon.attack);&#13;
        defense = uint256(mon.defense);&#13;
        spAttack = uint256(mon.spAttack);&#13;
        spDefense = uint256(mon.spDefense);&#13;
        speed = uint256(mon.speed);&#13;
        typeOne = uint256(mon.typeOne);&#13;
        typeTwo = uint256(mon.typeTwo);&#13;
        mID = uint256(mon.mID);&#13;
        tradeable = bool(mon.tradeable);&#13;
        &#13;
        // hack to overcome solidity's stack limitation in monster struct....&#13;
        uID = _id;&#13;
            &#13;
        }&#13;
&#13;
        &#13;
        // this method only returns the "base" powerlevel of a monster which will be used&#13;
        // in more advanced fighting calculations later on&#13;
    function getMonsterPowerLevel(uint256 _tokenId) external view returns (&#13;
            uint256 powerlevel&#13;
        ) {&#13;
            Monster storage mon = monsters[_tokenId];&#13;
            uint8[7] storage IVs = monsterIdToIVs[_tokenId];&#13;
&#13;
            &#13;
            powerlevel = mon.hp + IVs[0] + mon.attack + IVs[1] + mon.defense + IVs[2] + mon.spAttack + IVs[3] + mon.spDefense + IVs[4] + mon.speed + IVs[5];&#13;
        }&#13;
        &#13;
        &#13;
        &#13;
&#13;
   &#13;
    &#13;
    function isTrainer(address _check)&#13;
    external &#13;
    view &#13;
    returns (&#13;
        bool isTrainer&#13;
    ) {&#13;
        Trainer storage trainer = addressToTrainer[_check];&#13;
&#13;
        if (trainer.currArea &gt; 0)&#13;
            return true;&#13;
        else&#13;
            return false;&#13;
    }&#13;
   &#13;
&#13;
    &#13;
   &#13;
   &#13;
    function withdrawBalance() external onlyOwner {&#13;
       &#13;
        uint256 balance = this.balance;&#13;
       &#13;
       &#13;
        owner.transfer(balance);&#13;
        &#13;
    }&#13;
&#13;
    // after we have setup everything we can unlock the game&#13;
    // for public&#13;
    function launchGame() external onlyOwner {&#13;
        hasLaunched = true;&#13;
    }&#13;
}